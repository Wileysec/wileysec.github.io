[{"title":"CommonCollections6利用链分析","date":"2022-09-23T08:52:26.247Z","url":"/Java%E5%AE%89%E5%85%A8/36f045236875.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonCollections","/tags/CommonCollections/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"利用条件不限制JDK版本、CommonCollections版本 利用链 利用链分析 对上面代码进行分析，发现和CC1的LayzMap链很类似，不过后面的用法不同。 那么我们接着CC1的获取到LazyMap对象开始说起，在LayzMap类中的decorate方法返回了LazyMap对象，其对象的get方法中调用了factory的transform方法，即触发Payload。 CC6这条链后面使用了TideMapEntry类，构造方法分别初始化变量。 可知，map变量即是我们的lazymap对象，而想调用到chainedTransformer的transform方法，就必须要调用lazymap对象的get方法，那么在TideMapEntry类中找找看有没有地方调用了。 发现getValue方法调用了，再找一下是哪个函数调用了getValue方法 在其类中发现hashCode方法中调用了，那么后续我们怎么去利用调用到hashCode方法呢？还记得URLDNS链吗？在HashMap中调用put方法中会调用到hashCode方法。 这里使用HashMap对象将TiedMapEntry对象put进去，这样在反序列化HashMap对象时，就会调用到HashMap的readObject方法，其方法有调用hash方法 这样就能调用到我们上面说的lazymap对象的get方法 在序列化时成功执行，在序列化时触发并不是我们想要的，我们需要的是在反序列化时触发。想要解决这个问题，我们需要知道为什么在序列化时就能触发，因为HashMap对象在调用put方法时调用了hash方法，进而一步一步往下执行，TiedMapEntry-&gt;getValue()、LazyMap-&gt;get()、ChainedTransformer-&gt;transform() 我们只需要将这三个中的一个对象先放置一个空的对象，再使用反射修改其对象的属性即可。 这里在LazyMap调用decorate方法时，将factory参数赋值成一个没有意义的ConstantTransformer对象，这样在序列化时就不会触发Payload，再使用反射将factory变量值设置成Payload，这样在反序列化时就能够触发Payload了。 在反序列化时并没有触发，这里和URLDNS链很像，在调用hash方法后判断了HashMap对象的key是否包含指定 lazymap对象的key 在序列化时，判断不存在aaa这个key则会触发ChainedTransformer的transform方法，然后将其key添加到HashMap对象中，那么在下次反序列化时就执行不到158行到160行了，即不会触发Payload，那么有什么办法吗？当然有的，删除innerMap或lazymap对象的key即可。 至此执行成功，整条链都理清楚了，下面是整条链的利用过程代码。 "},{"title":"CommonCollections1利用链分析","date":"2022-07-14T08:41:00.545Z","url":"/Java%E5%AE%89%E5%85%A8/20a3d848dbb2.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonCollections","/tags/CommonCollections/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"利用条件CommonsCollections 3.1 - 3.2.1 JDK版本：1.7~1.8u71（之后已修复不可利用） 利用链介绍 new ConstantTransformer() 调用父类构造方法，并且将参数对象赋值给常量 iConstant new InvokeTransformer() 调用父类构造方法，并且对 InvokeTransformer 类的 iMethodName、iParamTypes、iArgs 进行赋值 InvokeTransformer 类实现了 Transformer 接口，来看看实现接口的 transform 方法 这看起来像个后门，获取对象的Class，然后获取我们上面写好的方法和参数并执行，这就是一个任意命令执行的点。 new ChainedTransformer() 也只是对常量进行赋值操作 因为 ChainedTransformer 类也实现了 Transformer 接口，再看看 transform 方法 这里对 iTransformers 进行循环执行 transform 方法，并且第一个执行的结果是下一个执行 transform 方法的参数对象。在上面，我们将 Transformer 对象数组赋值给了常量 iTransformers，如果调用 transform 方法那么就实现了链式调用，相当于 ChainedTransformer 把 Transformer 对象数组中所有对象串起来执行。 那么构造好了这么个链，我们如何去执行到 ChainedTransformer 中的 transform 方法呢？ 在 TransformedMap 类中发现 checkSetValue 方法中调用了 transform 方法，且 value 参数也是可控的 来看看这个类的构造方法，由于我们需要 TransformedMap 类的实例化对象，TransformedMap 的构造方法貌似不太适合，而这个类的 decorate 方法实例化了 TransformedMap 类并且返回了，是我们想要的！ 那么问题又来了，我们如何执行到 checkSetValue 方法呢？ 查找后，发现该执行点在 AbstractInputCheckedMapDecorator 抽象类中的内部类 MapEntry 中 那么我们只要想办法执行到 setValue 方法，就需要获取到获取到 MapEntry 类的实例化对象 看一看是哪个地方实例化了 MapEntry 类 还是在 AbstractInputCheckedMapDecorator 抽象类中的内部类 EntrySetIterator 再顺藤摸瓜看看谁实例化了 EntrySetIterator 类 发现还是在 AbstractInputCheckedMapDecorator 抽象类中的内部类 EntrySet 经过一番查找，发现实例化 EntrySet 构造方法还是在 AbstractInputCheckedMapDecorator 抽象类中 由于 TransformedMap 继承了 AbstractInputCheckedMapDecorator 抽象类，因此我们可以执行调用 entrySet 方法，接下来就是链式调用就可以得到 MapEntry 对象了，类型是 Map.Entry 得到 MapEntry 对象后，即可调用我们上面找到的 setValue 方法，这条链我们就清楚了。而我们研究的是在反序列化时自动触发调用链，现在研究的这条并不是，所以接下来按照两条链去研究。 TransformedMap链 LazyMap链ysoserial工具中的利用链 利用链分析TransformedMap链不使用反射 使用反射完整 TransformedMap 链利用代码如下 下面是JDK1.8u65版本的 AnnotationInvocationHandler 注解类，可以看到，构造函数的 memberValues 接受一个 Map 类型的对象，并赋值到本类的变量 memberValues AnnotationInvocationHandler 注解类重写了 readObject 方法，对我们传入的 Map 对象进行了遍历，在下面我们看到执行了 setValue 方法（如果没有setValue方法的版本，则不能利用成功）。 那么在上面代码中注释写到了，必须key为value，那是为什么呢？ 在这里获取了注解类型，并且在446行获取了这个注解类型的成员变量值，447行进行了判断，只要不为Null则会继续往下执行，否则无法执行到 setValue 方法。 上面的 type 变量其实就是我们在反射获取到 AnnotationInvocationHandler 注解类后实例化的参数 Target.class，为什么要选择这个注解类呢？ 因为 Target.class 有枚举类型成员变量，且是 value 这就解释了上面我们为什么key只能是value的原因。 最后，进行序列化和反序列化操作后，成功弹出计算器。 LazyMapLazyMap是ysoserial工具中的CC1链，而TransformedMap是国内流传的。 LazyMap只需要调用get方法即可执行命令 该方法实例化了LazyMap类，继续跟进 LazyMap继承了AbstractMapDecorator抽象类，判断了传递的Map对象是否是Null，不是则进行赋值操作。 再回到LazyMap构造方法中，发现对传递的chainedTransformer参数赋值给LazyMap的factory变量。 再找到get方法，可以看到，调用了factory对象的transform方法 在 invoke 方法中发现调用了get方法，由于 invoke 方法是在对象代理时才能触发，将这个对象进行Proxy代理，Proxy也实现了序列化接口，所以也是可以反序列化的，在readObject的时候，调用任意方法就会执行AnnotationInvocationHandler的invoke方法，此时还不能对此进行反序列化因为此时的入口点为sun.reflect.annotation.AnnotationInvocationHandler#readObject AnnotationInvocationHandler的invoke方法会调用LazyMap对象的get方法，就可以调用transform方法执行到恶意Payload invoke方法需要调用任意方法，才可触发，对AnnotationInvocationHandler对象进行动态代理，在readyObject方法被执行时就可调用到invoke方法 AnnotationInvocationHandler的memberValues变量接受的Map类型，所以代理对象类型也是Map，这里我们不能直接进行反序列化，我们需要再套一层执行到handler对象的AnnotationInvocationHandler类中的readObject方法即可。 以下是LazyMap链的完整代码 "},{"title":"URLDNS利用链分析","date":"2022-06-22T08:35:17.669Z","url":"/Java%E5%AE%89%E5%85%A8/c180fda4a6eb.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["URLDNS","/tags/URLDNS/"]],"categories":[["Java安全","/categories/Java%E5%AE%89%E5%85%A8/"]],"content":"利用链 URLDNS利用链如下： HashMap.readObject() -&gt; HashMap.putVal() -&gt; HashMap.hash() -&gt; URL.hashCode() -&gt; URLStreamHandler.hashCode() -&gt; URL.getHostAddress() -&gt; URL.getByName() 利用链分析Java中Map集合有Key和Value，可以接受任何数据类型的数据。入口类的参数是可控的并且可以是任意类或对象。 其中HashMap是Map接口的实现类，它继承了Serializable，HashMap是可被序列化的。 在HashMap重写了 readyObject 方法 在 readObject 方法中调用了 putVal 方法，在 putVal 方法中调用了 hash 方法 继续跟进，调用了 hash 方法中的 key 参数对象的 hashCode 方法 这里，参数是哪个对象就会调用哪个对象的 hashCode 方法 Java中的 URL 类，重写了 hashCode 方法并且可以DNS请求 找到 URL 类，重写了 hashCode 方法 这里的逻辑是，当 hashCode 变量为 -1 时才会执行到 handler.hashCode() 方法 handler 变量是 URLStreamHandler 类 找到 URLStreamHandler 类中的 hashCode 方法 调用了 getHostAddress 方法 再继续跟进，getByName 方法可以发起DNS请求 到这里，我们就理清楚URLDNS链的整个过程了。 利用链利用在上面，我们说到 hashCode 变量为 -1 是才会执行 handler.hashCode() 方法，该变量默认为 -1，那么在利用时就会出现一个问题，在执行 HashMap.put 方法时就会进行一次请求，无法确认是在反序列化时进行的DNS请求还是在序列化HashMap类时，HashMap的put方法导致的DNS请求。 先对 hashMap 对象进行序列化生成 obj.ser 文件 当程序接受一个序列化对象文件并反序列化操作时就读取了序列化的 HashMap 对象，此时 HashMap 的 hashCode 值为 -1 ，即可进行DNS查询。"},{"title":"PHP常见的利用协议","date":"2022-01-12T03:46:40.167Z","url":"/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/de9f49bb405f.html","tags":[["PHP","/tags/PHP/"],["协议","/tags/%E5%8D%8F%E8%AE%AE/"]],"categories":[["技术分享","/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":" PHP伪协议就是PHP支持的一些协议，并且封装起来使用的协议，就叫伪协议 file:&#x2F;&#x2F; file协议用来访问本地系统文件的，在渗透测试中常用来读取系统文件 条件： allow_url_include 为 On 这里的协议比较容易理解，和访问本地系统文件一样读取就可以了 file://C:\\\\windows\\\\win.ini php:&#x2F;&#x2F;php:&#x2F;&#x2F;filter 这种协议一般出现在PHP的文件读取写入函数中 条件： allow_url_include 为 On 简单理解一下这个协议，它能够处理数据流，比如读取文件时通过base64进行加密输出 php://filter/read=convert.base64-encode/resource=../../config/database.php 再来看个例子，也是实战中比较多的 在写入文件之前，加入一个PHP的退出函数 输入Payload为 txt=PD9waHAgcGhwaW5mbygpOyA/Pg==&amp;filename=php://filter/write=convert.base64-decode/resource=a.php 时报错了 这是由于base64编码，在解码时是4个字节为一组，如果不足在编码前补充对应字符 txt=bbPD9waHAgcGhwaW5mbygpOyA/Pg==&amp;filename=php://filter/write=string.strip_tags|convert.base64-decode/resource=a.php 此时成功写入 还有一个方法，使用这个协议的 string.strip_tags 方法，XML遇到PHP标签时，会解析成XML标签，使用这个方法可以删除这个标签，然后再处理输入流 txt=PD9waHAgcGhwaW5mbygpOyA/Pg==&amp;filename=php://filter/write=string.strip_tags|convert.base64-decode/resource=a.php 详细过程看： php:&#x2F;&#x2F;input 输入流input，访问请求的原始输入流，当 enctype=&quot;multipart/form-data&quot; 的时候，php:&#x2F;&#x2F;input 是无效的，只要 enctype 值不是 multipart/form-data ，这个协议就管用 条件： allow_url_include 为 On enctype 值不为 multipart/form-data 看一个例子 这里就可以使用 php://input 协议 这里有一个很疑惑的点，输入流原始数据必须符合参数化形式，不然不会被执行，网上很多文章都是不需要的，PHP5.4版本貌似没用 data:&#x2F;&#x2F; data:// 数据流封装器，漏洞出现在PHP文件包含处 条件： allow_url_include 为 On allow_url_fopen 为 On ?p=data://text/plain;base64,YWFhYWFhYQ== 该协议常用来封装数据，可以使用base64进行加密传输，输出时可自动解密为明文 aaaaaaa ?p=data://text/plain,&lt;?php phpinfo();?&gt; ?p=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2B 在base64编码后，需要对base64编码特殊字符做URL编码，否则浏览器识别不了 zip:&#x2F;&#x2F; zip:// 伪协议的格式为 zip://[压缩文件路径]#[压缩文件内的子文件名] 将PHP文件放在一个文件夹中，将这个文件夹压缩成ZIP格式，再将压缩文件后缀改为 .jpg 这里需要注意的是 # 需要进行URL编码 常用于在文件包含中使用 ?p=zip://a.jpg%231.php 将1.php写成一句话木马，通过Webshell管理工具进行连接 phar:&#x2F;&#x2F; phar 是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。 在这里，我测试了很多网上的方法，只测试成功了一个 首先，这里要创建一个 phar ，在本地写好并且运行创建 在本地创建的时候注意了，将 php.ini 中的 phar.readonly 设置为Off，否则无法生成phar文件 使用命令 php 1.php 执行后，会在当前目录生成一个 a.zip 文件 a.zip 为创建的phar文件名，这里使用的是 zip 格式，读取一句话木马文件 a.php 写入到phar压缩包中的 a.jpg 中 若文件包含可控，直接传入参数 phar://a.zip/a.jpg 即可执行我们想要执行的代码 还有一些其他操作："},{"title":"云函数的代理IP利用面","date":"2021-08-02T06:27:47.000Z","url":"/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/618dcd2c2088.html","tags":[["云函数","/tags/%E4%BA%91%E5%87%BD%E6%95%B0/"],["代理IP","/tags/%E4%BB%A3%E7%90%86IP/"]],"categories":[["技术分享","/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"0x01 前言什么是云函数？云函数（Serverless Cloud Function，SCF）是云计算厂商为企业和开发者们提供的无服务器执行环境，可在无需购买和管理服务器的情况下运行代码， 是实时文件处理和数据处理等场景下理想的计算平台。只需使用 SCF 平台支持的语言编写核心代码并设置代码运行的条件，即可在某云基础设施上弹性、安全地运行代码。 为什么通过云函数代理IP？这是因为云函数会自动的在同一个地域内的多个可用区部署，在请求目标时，会自动调用不同的可用区的IP地址。这样一来，每次请求IP会发生改变，也就达到了我们想要建立一个代理池的目的。 0x02 构建云函数代理池本地环境系统：macOS Big Sur Python版本：3.7.7 代理客户端：mitmproxy 云函数厂商：腾讯云 配置云函数新建云函数 选择自定义部署，运行环境为 Python ，通过在线编辑，将 SCFProxy 工具中的 server.py 文件代码替换进去，然后点击完成会自动部署 创建触发器 按照图示，依次选择创建API网关触发器 将访问路径记下 修改代理客户端配置 打开 SCFProxy 工具目录下的 HTTP，编辑 client.py 文件，将API网关触发器中的访问路径地址加入到 scf_servers 中 0x03 本地代理 本文章使用的代理客户端为 mitmproxy ，由于使用的是Python脚本处理代理请求，还需要使用pip安装 mitmproxy 模块（建议在官网下载对应的whl文件进行安装），这里需要注意安装对应版本的 mitmproxy 否则可能会出现一些问题。本文使用代理客户端的版本是 7.0.0，Python模块版本是：7.0.0。 为了方便，我将 client.py 文件复制到了 mitmproxy 工具目录中 然后执行 ./mitmdump -s client.py -p 8081 --no-http2 即可在本地端口8081上开启代理 通过浏览器代理工具进行代理，代理协议为 HTTP 代理服务器为 127.0.0.1 代理端口为 8081 浏览器代理后，可以看到IP地址也变了，每次请求IP地址都会变化 可以看到访问网页的请求都会经过云函数请求返回到本地 0x04 参考资料链接【干货】利用云函数实现免费IP代理 利用云函数（SCF）打造海量代理池 工具mitmproxy SCFProxy"},{"title":"About Me","date":"2023-08-08T13:10:28.729Z","url":"/about/index.html","categories":[[" ",""]],"content":"正在努力成为一名合格的红队选手（混子选手），喜欢研究Java安全方向和一些安全开发的内容 如若文章中内容存在错误，希望各位佬们指正 Wechat：Nzc2OTZjNjU3OTczNjU2Mw&#x3D;&#x3D;"},{"title":"友情链接","date":"2023-08-08T12:47:26.887Z","url":"/friends/index.html","categories":[[" ",""]]},{"title":"Project","date":"2023-05-28T09:12:53.047Z","url":"/project/index.html","categories":[[" ",""]]},{"title":"Series","date":"2023-05-28T09:12:53.041Z","url":"/series/index.html","categories":[[" ",""]]},{"title":"标签","date":"2023-08-08T14:08:00.216Z","url":"/tags/index.html","categories":[[" ",""]]},{"date":"2023-08-08T09:18:35.256Z","url":"/search/index.html","categories":[[" ",""]]}]